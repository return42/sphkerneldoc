.. -*- coding: utf-8; mode: rst -*-

========
mt2063.c
========



.. _xref_MT2063_gcd:

MT2063_gcd
==========

.. c:function:: u32 MT2063_gcd (u32 u, u32 v)

    Uses Euclid's algorithm

    :param u32 u:

        _undescribed_

    :param u32 v:

        _undescribed_



Description
-----------



**u**, **v**:	Unsigned values whose GCD is desired.


Returns THE greatest common divisor of u and v, if either value is 0,
the other value is returned as the result.




.. _xref_IsSpurInBand:

IsSpurInBand
============

.. c:function:: u32 IsSpurInBand (struct MT2063_AvoidSpursData_t * pAS_Info, u32 * fm, u32 * fp)

    Checks to see if a spur will be present within the IF's bandwidth. (fIFOut +/- fIFBW, -fIFOut +/- fIFBW)

    :param struct MT2063_AvoidSpursData_t * pAS_Info:
        Avoid Spurs information block

    :param u32 * fm:
        If spur, amount f_IF1 has to move negative

    :param u32 * fp:
        If spur, amount f_IF1 has to move positive



Description
-----------

 Returns 1 if an LO spur would be present, otherwise 0.



Description
-----------

 Returns 1 if an LO spur would be present, otherwise 0.




.. _xref_mt2063_lockStatus:

mt2063_lockStatus
=================

.. c:function:: int mt2063_lockStatus (struct mt2063_state * state)

    Checks to see if LO1 and LO2 are locked

    :param struct mt2063_state * state:
        struct mt2063_state pointer



Description
-----------

This function returns 0, if no lock, 1 if locked and a value < 1 if error




.. _xref_MT2063_fLO_FractionalTerm:

MT2063_fLO_FractionalTerm
=========================

.. c:function:: u32 MT2063_fLO_FractionalTerm (u32 f_ref, u32 num, u32 denom)

    Calculates the portion contributed by FracN / denom. This function preserves maximum precision without risk of overflow. It accurately calculates f_ref * num / denom to within 1 HZ with fixed math.

    :param u32 f_ref:

        _undescribed_

    :param u32 num:
        Fractional portion of the multiplier

    :param u32 denom:
        denominator portion of the ratio



Description
-----------

This calculation handles f_ref as two separate 14-bit fields.
Therefore, a maximum value of 2^28-1 may safely be used for f_ref.
This is the genesis of the magic number "14" and the magic mask value of
0x03FFF.


This routine successfully handles denom values up to and including 2^18.



Returns
-------

f_ref * num / denom




.. _xref_MT2063_CalcLO2Mult:

MT2063_CalcLO2Mult
==================

.. c:function:: u32 MT2063_CalcLO2Mult (u32 * Div, u32 * FracN, u32 f_LO, u32 f_LO_Step, u32 f_Ref)

    Calculates Integer divider value and the numerator value for a FracN PLL.

    :param u32 * Div:
        OUTPUT: Whole number portion of the multiplier

    :param u32 * FracN:
        OUTPUT: Fractional portion of the multiplier

    :param u32 f_LO:
        desired LO frequency.

    :param u32 f_LO_Step:
        Minimum step size for the LO (in Hz).

    :param u32 f_Ref:
        SRO frequency.



Description
-----------



                 This function assumes that the f_LO and f_Ref are
                 evenly divisible by f_LO_Step.



Returns
-------

Recalculated LO frequency.


