# -*- coding: utf-8; mode: python -*-
# pylint: disable=C0330, R0903

u"""
    sphinx.writers.xelatex
    ~~~~~~~~~~~~~~~~~~~~~~

    :copyright:  Copyright (C) 2016 Markus Heiser
    :license:    GPL V3.0, see LICENSE for details.

    TODO: documenting ....

"""

# ==============================================================================
#  imports ...
# ==============================================================================

from docutils import nodes, writers


# ==============================================================================
class XeLaTeXWriter(writers.Writer):
# ==============================================================================

    """A writer for Unicode-based LaTeX variants (XeTeX, LuaTeX)

    Supports 'xetex', 'xelatex' and 'luatex' writers and implements the
    ``self.translator_class`` as ``XeLaTeXTranslator``.

    ``XeLaTeXWriter`` inherits from docutils's ``writers.Writer``.
    """

    supported = ('lxtex', 'xetex','xelatex','luatex', 'lualatex')
    """Formats this writer supports."""

    def __init__(self, builder):
        writers.Writer.__init__(self)
        self.output  = None
        self.builder = builder
        self.translator_class = XeLaTeXTranslator

    def translate(self):
        """Do final translation of `self.document` into `self.output`.

        Called from `write`.
        """
        visitor = self.translator_class(self.document, self.builder)
        self.document.walkabout(visitor)
        self.output = visitor.astext()

# ==============================================================================
# Templates of the XeLaTeXTranslator
# ==============================================================================

class XeLaTeX_TEMPLATES(object):
    """Building blocks for XeLaTeX templates

    * HEADER
    * BEGIN_DOC
    * FOOTER
    """

XeLaTeX_TEMPLATES.HEADER = r"""%% Generated by Sphinx.
\documentclass[%(papersize)s,%(pointsize)s%(classoptions)s]{%(docclass)s}

%(preamble)s

\title{%(title)s}
\date{%(date)s}
\release{%(release)s}
\author{%(author)s}
\newcommand{\sphinxlogo}{%(logo)s}
\renewcommand{\releasename}{%(releasename)s}
%(makeindex)s
"""

XeLaTeX_TEMPLATES.BEGIN_DOC = r"""
\begin{document}
%(maketitle)s
%(tableofcontents)s
"""

XeLaTeX_TEMPLATES.FOOTER = r"""
\renewcommand{\indexname}{%(indexname)s}
%(printindex)s
\end{document}
"""

# ==============================================================================
class XeLaTeXTranslator(nodes.NodeVisitor):
# ==============================================================================

    u"""Docutils *visitor* pattern of the XeLaTeX writer.

    The ``XeLaTeXTranslator`` class inherits from the
    ``sphinx.writers.latex.LaTeXTranslator`.
    """

    TEMPLATES = XeLaTeX_TEMPLATES

    default_ctx = {
        'papersize':         'letterpaper'
        , 'pointsize':       '12pt'
        , 'classoptions':    ''
        , 'longtable':       '\\usepackage{longtable}'
        , 'preamble':        ''
        , 'title':           ''
        , 'date':            ''
        , 'release':         ''
        , 'author':          ''
        , 'logo':            ''
        , 'releasename':     'Release'
        , 'makeindex':       '\\makeindex'
        , 'maketitle':       '\\maketitle'
        , 'tableofcontents': '\\tableofcontents'
        , 'footer':          ''
        , 'printindex':      '\\printindex'
        }

    def __init__(self, document, builder):
        docutils.nodes.NodeVisitor.__init__(self, document)

        self.body      = []
        self.builder   = builder
        self.document  = document
        self.elements  = self.default_ctx.copy()
        # TODO ...
        self.elements.update(self.document.docCfg)

        # XeLaTeX makes no use of the sphinx.util.texescape, but the
        # sphinx.highlighting.PygmentsBridge uses the *tex_hl_escape_map_new*
        # which has to be initialized.
        from sphinx.util import texescape
        texescape.init()

        self.highlighter = highlighting.PygmentsBridge(
            'latex'
            , self.builder.config.pygments_style or 'tango'  # prefer tango as default
            , self.builder.config.trim_doctest_flags
        )

        self.context   = []
        self.descstack = []
        self.bibitems  = []
        self.table     = None
        self.next_table_colspec = None

        # stack of [language, linenothreshold] settings per file
        # the first item here is the default and must not be changed
        # the second item is the default for the master file and can be changed
        # by .. highlight:: directive in the master file

        self.hlsettingstack = 2 * [
            [self.builder.config.highlight_language, sys.maxint]
            ]

        self.footnotestack    = []
        self.curfilestack     = []
        self.handled_abbrs    = set()

        self.next_section_ids = set()
        self.next_figure_ids  = set()
        self.next_table_ids   = set()

        # flags
        # -----

        self.verbatim           = None
        self.in_title           = 0
        self.in_production_list = 0
        self.in_footnote        = 0
        self.in_caption         = 0
        self.first_document     = 1
        self.this_is_the_title  = 1
        self.literal_whitespace = 0
        self.no_contractions    = 0
        self.compact_list       = 0
        self.first_param        = 0


    def astext(self):
        return (
            self.TEMPLATES.HEADER % self.elements
            + self.highlighter.get_stylesheet()
            + u''.join(self.body)
            + '\n' + self.elements['footer'] + '\n'
            + self.generate_indices()
            + self.TEMPLATES.FOOTER % self.elements
            )

    def visit_document(self, node):
        self.footnotestack.append(self.collect_footnotes(node))
        self.curfilestack.append(node.get('docname', ''))
        if self.first_document == 1:
            # the first document is all the regular content ...
            self.body.append(self.TEMPLATES.BEGIN_DOC % self.elements)
            self.first_document = 0
        elif self.first_document == 0:
            # ... and all others are the appendices
            self.body.append(u'\n\\appendix\n')
            self.first_document = -1
        if 'docname' in node:
            self.body.append(self.hypertarget(':doc'))
        # "- 1" because the level is increased before the title is visited
        self.sectionlevel = self.top_sectionlevel - 1

    def depart_document(self, node):
        if self.bibitems:
            widest_label = ""
            for bi in self.bibitems:
                if len(widest_label) < len(bi[0]):
                    widest_label = bi[0]
            self.body.append(u'\n\\begin{thebibliography}{%s}\n' % widest_label)
            for bi in self.bibitems:
                target = self.hypertarget(bi[2] + ':' + bi[0].lower(),
                                          withdoc=False)
                self.body.append(u'\\bibitem[%s]{%s}{%s %s}\n' %
                    (bi[0], self.idescape(bi[0]), target, bi[1]))
            self.body.append(u'\\end{thebibliography}\n')
            self.bibitems = []

