.. -*- coding: utf-8; mode: rst -*-

========
skbuff.h
========


.. _`skb_shared_hwtstamps`:

struct skb_shared_hwtstamps
===========================

.. c:type:: skb_shared_hwtstamps

    hardware time stamps


.. _`skb_shared_hwtstamps.definition`:

Definition
----------

.. code-block:: c

  struct skb_shared_hwtstamps {
    ktime_t hwtstamp;
  };


.. _`skb_shared_hwtstamps.members`:

Members
-------

:``hwtstamp``:
    hardware time stamp transformed into duration
    since arbitrary point in time




.. _`skb_shared_hwtstamps.description`:

Description
-----------

Software time stamps generated by :c:func:`ktime_get_real` are stored in
skb->tstamp.

hwtstamps can only be compared against other hwtstamps from
the same device.

This structure is attached to packets as part of the
:c:type:`struct skb_shared_info <skb_shared_info>`. Use :c:func:`skb_hwtstamps` to get a pointer.



.. _`skb_mstamp`:

struct skb_mstamp
=================

.. c:type:: skb_mstamp

    multi resolution time stamps


.. _`skb_mstamp.definition`:

Definition
----------

.. code-block:: c

  struct skb_mstamp {
    union {unnamed_union};
  };


.. _`skb_mstamp.members`:

Members
-------

:``{unnamed_union}``:
    anonymous




.. _`skb_mstamp_get`:

skb_mstamp_get
==============

.. c:function:: void skb_mstamp_get (struct skb_mstamp *cl)

    get current timestamp

    :param struct skb_mstamp \*cl:
        place to store timestamps



.. _`skb_mstamp_us_delta`:

skb_mstamp_us_delta
===================

.. c:function:: u32 skb_mstamp_us_delta (const struct skb_mstamp *t1, const struct skb_mstamp *t0)

    compute the difference in usec between two skb_mstamp

    :param const struct skb_mstamp \*t1:
        pointer to newest sample

    :param const struct skb_mstamp \*t0:
        pointer to oldest sample



.. _`sk_buff`:

struct sk_buff
==============

.. c:type:: sk_buff

    socket buffer


.. _`sk_buff.definition`:

Definition
----------

.. code-block:: c

  struct sk_buff {
    union {unnamed_union};
    __u16 inner_transport_header;
    __u16 inner_network_header;
    __u16 inner_mac_header;
    __be16 protocol;
    __u16 transport_header;
    __u16 network_header;
    __u16 mac_header;
    sk_buff_data_t tail;
    sk_buff_data_t end;
    unsigned char * head;
    unsigned char * data;
    unsigned int truesize;
    atomic_t users;
  };


.. _`sk_buff.members`:

Members
-------

:``{unnamed_union}``:
    anonymous

:``inner_transport_header``:
    Inner transport layer header (encapsulation)

:``inner_network_header``:
    Network layer header (encapsulation)

:``inner_mac_header``:
    Link layer header (encapsulation)

:``protocol``:
    Packet protocol from driver

:``transport_header``:
    Transport layer header

:``network_header``:
    Network layer header

:``mac_header``:
    Link layer header

:``tail``:
    Tail pointer

:``end``:
    End pointer

:``head``:
    Head of buffer

:``data``:
    Data head pointer

:``truesize``:
    Buffer size

:``users``:
    User count - see {datagram,tcp}.c




.. _`skb_dst`:

skb_dst
=======

.. c:function:: struct dst_entry *skb_dst (const struct sk_buff *skb)

    returns skb dst_entry

    :param const struct sk_buff \*skb:
        buffer



.. _`skb_dst.description`:

Description
-----------

Returns skb dst_entry, regardless of reference taken or not.



.. _`skb_dst_set`:

skb_dst_set
===========

.. c:function:: void skb_dst_set (struct sk_buff *skb, struct dst_entry *dst)

    sets skb dst

    :param struct sk_buff \*skb:
        buffer

    :param struct dst_entry \*dst:
        dst entry



.. _`skb_dst_set.description`:

Description
-----------

Sets skb dst, assuming a reference was taken on dst and should
be released by :c:func:`skb_dst_drop`



.. _`skb_dst_set_noref`:

skb_dst_set_noref
=================

.. c:function:: void skb_dst_set_noref (struct sk_buff *skb, struct dst_entry *dst)

    sets skb dst, hopefully, without taking reference

    :param struct sk_buff \*skb:
        buffer

    :param struct dst_entry \*dst:
        dst entry



.. _`skb_dst_set_noref.description`:

Description
-----------

Sets skb dst, assuming a reference was not taken on dst.
If dst entry is cached, we do not take reference and dst_release
will be avoided by refdst_drop. If dst entry is not cached, we take
reference, so that last dst_release can destroy the dst immediately.



.. _`skb_dst_is_noref`:

skb_dst_is_noref
================

.. c:function:: bool skb_dst_is_noref (const struct sk_buff *skb)

    Test if skb dst isn't refcounted

    :param const struct sk_buff \*skb:
        buffer



.. _`skb_fclone_busy`:

skb_fclone_busy
===============

.. c:function:: bool skb_fclone_busy (const struct sock *sk, const struct sk_buff *skb)

    check if fclone is busy

    :param const struct sock \*sk:

        *undescribed*

    :param const struct sk_buff \*skb:
        buffer



.. _`skb_fclone_busy.description`:

Description
-----------

Returns true if skb is a fast clone, and its clone is not freed.
Some drivers call :c:func:`skb_orphan` in their :c:func:`ndo_start_xmit`,
so we also check that this didnt happen.



.. _`skb_queue_empty`:

skb_queue_empty
===============

.. c:function:: int skb_queue_empty (const struct sk_buff_head *list)

    check if a queue is empty

    :param const struct sk_buff_head \*list:
        queue head



.. _`skb_queue_empty.description`:

Description
-----------

Returns true if the queue is empty, false otherwise.



.. _`skb_queue_is_last`:

skb_queue_is_last
=================

.. c:function:: bool skb_queue_is_last (const struct sk_buff_head *list, const struct sk_buff *skb)

    check if skb is the last entry in the queue

    :param const struct sk_buff_head \*list:
        queue head

    :param const struct sk_buff \*skb:
        buffer



.. _`skb_queue_is_last.description`:

Description
-----------

Returns true if ``skb`` is the last buffer on the list.



.. _`skb_queue_is_first`:

skb_queue_is_first
==================

.. c:function:: bool skb_queue_is_first (const struct sk_buff_head *list, const struct sk_buff *skb)

    check if skb is the first entry in the queue

    :param const struct sk_buff_head \*list:
        queue head

    :param const struct sk_buff \*skb:
        buffer



.. _`skb_queue_is_first.description`:

Description
-----------

Returns true if ``skb`` is the first buffer on the list.



.. _`skb_queue_next`:

skb_queue_next
==============

.. c:function:: struct sk_buff *skb_queue_next (const struct sk_buff_head *list, const struct sk_buff *skb)

    return the next packet in the queue

    :param const struct sk_buff_head \*list:
        queue head

    :param const struct sk_buff \*skb:
        current buffer



.. _`skb_queue_next.description`:

Description
-----------

Return the next packet in ``list`` after ``skb``\ .  It is only valid to
call this if :c:func:`skb_queue_is_last` evaluates to false.



.. _`skb_queue_prev`:

skb_queue_prev
==============

.. c:function:: struct sk_buff *skb_queue_prev (const struct sk_buff_head *list, const struct sk_buff *skb)

    return the prev packet in the queue

    :param const struct sk_buff_head \*list:
        queue head

    :param const struct sk_buff \*skb:
        current buffer



.. _`skb_queue_prev.description`:

Description
-----------

Return the prev packet in ``list`` before ``skb``\ .  It is only valid to
call this if :c:func:`skb_queue_is_first` evaluates to false.



.. _`skb_get`:

skb_get
=======

.. c:function:: struct sk_buff *skb_get (struct sk_buff *skb)

    reference buffer

    :param struct sk_buff \*skb:
        buffer to reference



.. _`skb_get.description`:

Description
-----------

Makes another reference to a socket buffer and returns a pointer
to the buffer.



.. _`skb_cloned`:

skb_cloned
==========

.. c:function:: int skb_cloned (const struct sk_buff *skb)

    is the buffer a clone

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_cloned.description`:

Description
-----------

Returns true if the buffer was generated with :c:func:`skb_clone` and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.



.. _`skb_header_cloned`:

skb_header_cloned
=================

.. c:function:: int skb_header_cloned (const struct sk_buff *skb)

    is the header a clone

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_header_cloned.description`:

Description
-----------

Returns true if modifying the header part of the buffer requires
the data to be copied.



.. _`skb_header_release`:

skb_header_release
==================

.. c:function:: void skb_header_release (struct sk_buff *skb)

    release reference to header

    :param struct sk_buff \*skb:
        buffer to operate on



.. _`skb_header_release.description`:

Description
-----------

Drop a reference to the header part of the buffer.  This is done
by acquiring a payload reference.  You must not read from the header
part of skb->data after this.



.. _`skb_header_release.note`:

Note 
-----

Check if you can use :c:func:`__skb_header_release` instead.



.. _`__skb_header_release`:

__skb_header_release
====================

.. c:function:: void __skb_header_release (struct sk_buff *skb)

    release reference to header

    :param struct sk_buff \*skb:
        buffer to operate on



.. _`__skb_header_release.description`:

Description
-----------

Variant of :c:func:`skb_header_release` assuming skb is private to caller.
We can avoid one atomic operation.



.. _`skb_shared`:

skb_shared
==========

.. c:function:: int skb_shared (const struct sk_buff *skb)

    is the buffer shared

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_shared.description`:

Description
-----------

Returns true if more than one person has a reference to this
buffer.



.. _`skb_share_check`:

skb_share_check
===============

.. c:function:: struct sk_buff *skb_share_check (struct sk_buff *skb, gfp_t pri)

    check if buffer is shared and if so clone it

    :param struct sk_buff \*skb:
        buffer to check

    :param gfp_t pri:
        priority for memory allocation



.. _`skb_share_check.description`:

Description
-----------

If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP_ATOMIC.

NULL is returned on a memory allocation failure.



.. _`skb_unshare`:

skb_unshare
===========

.. c:function:: struct sk_buff *skb_unshare (struct sk_buff *skb, gfp_t pri)

    make a copy of a shared buffer

    :param struct sk_buff \*skb:
        buffer to check

    :param gfp_t pri:
        priority for memory allocation



.. _`skb_unshare.description`:

Description
-----------

If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state ``pri`` must be ``GFP_ATOMIC``

``NULL`` is returned on a memory allocation failure.



.. _`skb_peek`:

skb_peek
========

.. c:function:: struct sk_buff *skb_peek (const struct sk_buff_head *list_)

    peek at the head of an &sk_buff_head

    :param const struct sk_buff_head \*list_:
        list to peek at



.. _`skb_peek.description`:

Description
-----------

Peek an :c:type:`struct sk_buff <sk_buff>`. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns ``NULL`` for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.



.. _`skb_peek_next`:

skb_peek_next
=============

.. c:function:: struct sk_buff *skb_peek_next (struct sk_buff *skb, const struct sk_buff_head *list_)

    peek skb following the given one from a queue

    :param struct sk_buff \*skb:
        skb to start from

    :param const struct sk_buff_head \*list_:
        list to peek at



.. _`skb_peek_next.description`:

Description
-----------

Returns ``NULL`` when the end of the list is met or a pointer to the
next element. The reference count is not incremented and the
reference is therefore volatile. Use with caution.



.. _`skb_peek_tail`:

skb_peek_tail
=============

.. c:function:: struct sk_buff *skb_peek_tail (const struct sk_buff_head *list_)

    peek at the tail of an &sk_buff_head

    :param const struct sk_buff_head \*list_:
        list to peek at



.. _`skb_peek_tail.description`:

Description
-----------

Peek an :c:type:`struct sk_buff <sk_buff>`. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns ``NULL`` for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.



.. _`skb_queue_len`:

skb_queue_len
=============

.. c:function:: __u32 skb_queue_len (const struct sk_buff_head *list_)

    get queue length

    :param const struct sk_buff_head \*list_:
        list to measure



.. _`skb_queue_len.description`:

Description
-----------

Return the length of an :c:type:`struct sk_buff <sk_buff>` queue.



.. _`__skb_queue_head_init`:

__skb_queue_head_init
=====================

.. c:function:: void __skb_queue_head_init (struct sk_buff_head *list)

    initialize non-spinlock portions of sk_buff_head

    :param struct sk_buff_head \*list:
        queue to initialize



.. _`__skb_queue_head_init.description`:

Description
-----------

This initializes only the list and queue length aspects of
an sk_buff_head object.  This allows to initialize the list
aspects of an sk_buff_head without reinitializing things like
the spinlock.  It can also be used for on-stack sk_buff_head
objects where the spinlock is known to not be used.



.. _`skb_queue_splice`:

skb_queue_splice
================

.. c:function:: void skb_queue_splice (const struct sk_buff_head *list, struct sk_buff_head *head)

    join two skb lists, this is designed for stacks

    :param const struct sk_buff_head \*list:
        the new list to add

    :param struct sk_buff_head \*head:
        the place to add it in the first list



.. _`skb_queue_splice_init`:

skb_queue_splice_init
=====================

.. c:function:: void skb_queue_splice_init (struct sk_buff_head *list, struct sk_buff_head *head)

    join two skb lists and reinitialise the emptied list

    :param struct sk_buff_head \*list:
        the new list to add

    :param struct sk_buff_head \*head:
        the place to add it in the first list



.. _`skb_queue_splice_init.description`:

Description
-----------

The list at ``list`` is reinitialised



.. _`skb_queue_splice_tail`:

skb_queue_splice_tail
=====================

.. c:function:: void skb_queue_splice_tail (const struct sk_buff_head *list, struct sk_buff_head *head)

    join two skb lists, each list being a queue

    :param const struct sk_buff_head \*list:
        the new list to add

    :param struct sk_buff_head \*head:
        the place to add it in the first list



.. _`skb_queue_splice_tail_init`:

skb_queue_splice_tail_init
==========================

.. c:function:: void skb_queue_splice_tail_init (struct sk_buff_head *list, struct sk_buff_head *head)

    join two skb lists and reinitialise the emptied list

    :param struct sk_buff_head \*list:
        the new list to add

    :param struct sk_buff_head \*head:
        the place to add it in the first list



.. _`skb_queue_splice_tail_init.description`:

Description
-----------

Each of the lists is a queue.
The list at ``list`` is reinitialised



.. _`__skb_queue_after`:

__skb_queue_after
=================

.. c:function:: void __skb_queue_after (struct sk_buff_head *list, struct sk_buff *prev, struct sk_buff *newsk)

    queue a buffer at the list head

    :param struct sk_buff_head \*list:
        list to use

    :param struct sk_buff \*prev:
        place after this buffer

    :param struct sk_buff \*newsk:
        buffer to queue



.. _`__skb_queue_after.description`:

Description
-----------

Queue a buffer int the middle of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.



.. _`skb_queue_head`:

skb_queue_head
==============

.. c:function:: void skb_queue_head (struct sk_buff_head *list, struct sk_buff *newsk)

    queue a buffer at the list head

    :param struct sk_buff_head \*list:
        list to use

    :param struct sk_buff \*newsk:
        buffer to queue



.. _`skb_queue_head.description`:

Description
-----------

Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.



.. _`skb_queue_tail`:

skb_queue_tail
==============

.. c:function:: void skb_queue_tail (struct sk_buff_head *list, struct sk_buff *newsk)

    queue a buffer at the list tail

    :param struct sk_buff_head \*list:
        list to use

    :param struct sk_buff \*newsk:
        buffer to queue



.. _`skb_queue_tail.description`:

Description
-----------

Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.



.. _`skb_dequeue`:

skb_dequeue
===========

.. c:function:: struct sk_buff *skb_dequeue (struct sk_buff_head *list)

    remove from the head of the queue

    :param struct sk_buff_head \*list:
        list to dequeue from



.. _`skb_dequeue.description`:

Description
-----------

Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or ``NULL`` if the list is empty.



.. _`skb_dequeue_tail`:

skb_dequeue_tail
================

.. c:function:: struct sk_buff *skb_dequeue_tail (struct sk_buff_head *list)

    remove from the tail of the queue

    :param struct sk_buff_head \*list:
        list to dequeue from



.. _`skb_dequeue_tail.description`:

Description
-----------

Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or ``NULL`` if the list is empty.



.. _`__skb_fill_page_desc`:

__skb_fill_page_desc
====================

.. c:function:: void __skb_fill_page_desc (struct sk_buff *skb, int i, struct page *page, int off, int size)

    initialise a paged fragment in an skb

    :param struct sk_buff \*skb:
        buffer containing fragment to be initialised

    :param int i:
        paged fragment index to initialise

    :param struct page \*page:
        the page to use for this fragment

    :param int off:
        the offset to the data with ``page``

    :param int size:
        the length of the data



.. _`__skb_fill_page_desc.description`:

Description
-----------

Initialises the ``i``\ 'th fragment of ``skb`` to point to :c:type:`struct size <size>` bytes at
offset ``off`` within ``page``\ .

Does not take any additional reference on the fragment.



.. _`skb_fill_page_desc`:

skb_fill_page_desc
==================

.. c:function:: void skb_fill_page_desc (struct sk_buff *skb, int i, struct page *page, int off, int size)

    initialise a paged fragment in an skb

    :param struct sk_buff \*skb:
        buffer containing fragment to be initialised

    :param int i:
        paged fragment index to initialise

    :param struct page \*page:
        the page to use for this fragment

    :param int off:
        the offset to the data with ``page``

    :param int size:
        the length of the data



.. _`skb_fill_page_desc.description`:

Description
-----------

As per :c:func:`__skb_fill_page_desc` -- initialises the ``i``\ 'th fragment of
``skb`` to point to ``size`` bytes at offset ``off`` within ``page``\ . In
addition updates ``skb`` such that ``i`` is the last fragment.

Does not take any additional reference on the fragment.



.. _`skb_headroom`:

skb_headroom
============

.. c:function:: unsigned int skb_headroom (const struct sk_buff *skb)

    bytes at buffer head

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_headroom.description`:

Description
-----------

Return the number of bytes of free space at the head of an :c:type:`struct sk_buff <sk_buff>`.



.. _`skb_tailroom`:

skb_tailroom
============

.. c:function:: int skb_tailroom (const struct sk_buff *skb)

    bytes at buffer end

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_tailroom.description`:

Description
-----------

Return the number of bytes of free space at the tail of an sk_buff



.. _`skb_availroom`:

skb_availroom
=============

.. c:function:: int skb_availroom (const struct sk_buff *skb)

    bytes at buffer end

    :param const struct sk_buff \*skb:
        buffer to check



.. _`skb_availroom.description`:

Description
-----------

Return the number of bytes of free space at the tail of an sk_buff
allocated by :c:func:`sk_stream_alloc`



.. _`skb_reserve`:

skb_reserve
===========

.. c:function:: void skb_reserve (struct sk_buff *skb, int len)

    adjust headroom

    :param struct sk_buff \*skb:
        buffer to alter

    :param int len:
        bytes to move



.. _`skb_reserve.description`:

Description
-----------

Increase the headroom of an empty :c:type:`struct sk_buff <sk_buff>` by reducing the tail
room. This is only allowed for an empty buffer.



.. _`skb_tailroom_reserve`:

skb_tailroom_reserve
====================

.. c:function:: void skb_tailroom_reserve (struct sk_buff *skb, unsigned int mtu, unsigned int needed_tailroom)

    adjust reserved_tailroom

    :param struct sk_buff \*skb:
        buffer to alter

    :param unsigned int mtu:
        maximum amount of headlen permitted

    :param unsigned int needed_tailroom:
        minimum amount of reserved_tailroom



.. _`skb_tailroom_reserve.description`:

Description
-----------

Set reserved_tailroom so that headlen can be as large as possible but
not larger than mtu and tailroom cannot be smaller than
needed_tailroom.
The required headroom should already have been reserved before using
this function.



.. _`pskb_trim_unique`:

pskb_trim_unique
================

.. c:function:: void pskb_trim_unique (struct sk_buff *skb, unsigned int len)

    remove end from a paged unique (not cloned) buffer

    :param struct sk_buff \*skb:
        buffer to alter

    :param unsigned int len:
        new length



.. _`pskb_trim_unique.description`:

Description
-----------

This is identical to pskb_trim except that the caller knows that
the skb is not cloned so we should never get an error due to out-
of-memory.



.. _`skb_orphan`:

skb_orphan
==========

.. c:function:: void skb_orphan (struct sk_buff *skb)

    orphan a buffer

    :param struct sk_buff \*skb:
        buffer to orphan



.. _`skb_orphan.description`:

Description
-----------

If a buffer currently has an owner then we call the owner's
destructor function and make the ``skb`` unowned. The buffer continues
to exist but is no longer charged to its former owner.



.. _`skb_orphan_frags`:

skb_orphan_frags
================

.. c:function:: int skb_orphan_frags (struct sk_buff *skb, gfp_t gfp_mask)

    orphan the frags contained in a buffer

    :param struct sk_buff \*skb:
        buffer to orphan frags from

    :param gfp_t gfp_mask:
        allocation mask for replacement pages



.. _`skb_orphan_frags.description`:

Description
-----------

For each frag in the SKB which needs a destructor (i.e. has an
owner) create a copy of that frag and release the original
page by calling the destructor.



.. _`skb_queue_purge`:

skb_queue_purge
===============

.. c:function:: void skb_queue_purge (struct sk_buff_head *list)

    empty a list

    :param struct sk_buff_head \*list:
        list to empty



.. _`skb_queue_purge.description`:

Description
-----------

Delete all buffers on an :c:type:`struct sk_buff <sk_buff>` list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.



.. _`netdev_alloc_skb`:

netdev_alloc_skb
================

.. c:function:: struct sk_buff *netdev_alloc_skb (struct net_device *dev, unsigned int length)

    allocate an skbuff for rx on a specific device

    :param struct net_device \*dev:
        network device to receive on

    :param unsigned int length:
        length to allocate



.. _`netdev_alloc_skb.description`:

Description
-----------

Allocate a new :c:type:`struct sk_buff <sk_buff>` and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.

``NULL`` is returned if there is no free memory. Although this function
allocates memory it can be called from an interrupt.



.. _`__dev_alloc_pages`:

__dev_alloc_pages
=================

.. c:function:: struct page *__dev_alloc_pages (gfp_t gfp_mask, unsigned int order)

    allocate page for network Rx

    :param gfp_t gfp_mask:
        allocation priority. Set __GFP_NOMEMALLOC if not for network Rx

    :param unsigned int order:
        size of the allocation



.. _`__dev_alloc_pages.description`:

Description
-----------

Allocate a new page.

``NULL`` is returned if there is no free memory.



.. _`__dev_alloc_page`:

__dev_alloc_page
================

.. c:function:: struct page *__dev_alloc_page (gfp_t gfp_mask)

    allocate a page for network Rx

    :param gfp_t gfp_mask:
        allocation priority. Set __GFP_NOMEMALLOC if not for network Rx



.. _`__dev_alloc_page.description`:

Description
-----------

Allocate a new page.

``NULL`` is returned if there is no free memory.



.. _`skb_propagate_pfmemalloc`:

skb_propagate_pfmemalloc
========================

.. c:function:: void skb_propagate_pfmemalloc (struct page *page, struct sk_buff *skb)

    Propagate pfmemalloc if skb is allocated after RX page

    :param struct page \*page:
        The page that was allocated from skb_alloc_page

    :param struct sk_buff \*skb:
        The skb that may need pfmemalloc set



.. _`skb_frag_page`:

skb_frag_page
=============

.. c:function:: struct page *skb_frag_page (const skb_frag_t *frag)

    retrieve the page referred to by a paged fragment

    :param const skb_frag_t \*frag:
        the paged fragment



.. _`skb_frag_page.description`:

Description
-----------

Returns the :c:type:`struct page <page>` associated with ``frag``\ .



.. _`__skb_frag_ref`:

__skb_frag_ref
==============

.. c:function:: void __skb_frag_ref (skb_frag_t *frag)

    take an addition reference on a paged fragment.

    :param skb_frag_t \*frag:
        the paged fragment



.. _`__skb_frag_ref.description`:

Description
-----------

Takes an additional reference on the paged fragment ``frag``\ .



.. _`skb_frag_ref`:

skb_frag_ref
============

.. c:function:: void skb_frag_ref (struct sk_buff *skb, int f)

    take an addition reference on a paged fragment of an skb.

    :param struct sk_buff \*skb:
        the buffer

    :param int f:
        the fragment offset.



.. _`skb_frag_ref.description`:

Description
-----------

Takes an additional reference on the ``f``\ 'th paged fragment of ``skb``\ .



.. _`__skb_frag_unref`:

__skb_frag_unref
================

.. c:function:: void __skb_frag_unref (skb_frag_t *frag)

    release a reference on a paged fragment.

    :param skb_frag_t \*frag:
        the paged fragment



.. _`__skb_frag_unref.description`:

Description
-----------

Releases a reference on the paged fragment ``frag``\ .



.. _`skb_frag_unref`:

skb_frag_unref
==============

.. c:function:: void skb_frag_unref (struct sk_buff *skb, int f)

    release a reference on a paged fragment of an skb.

    :param struct sk_buff \*skb:
        the buffer

    :param int f:
        the fragment offset



.. _`skb_frag_unref.description`:

Description
-----------

Releases a reference on the ``f``\ 'th paged fragment of ``skb``\ .



.. _`skb_frag_address`:

skb_frag_address
================

.. c:function:: void *skb_frag_address (const skb_frag_t *frag)

    gets the address of the data contained in a paged fragment

    :param const skb_frag_t \*frag:
        the paged fragment buffer



.. _`skb_frag_address.description`:

Description
-----------

Returns the address of the data within ``frag``\ . The page must already
be mapped.



.. _`skb_frag_address_safe`:

skb_frag_address_safe
=====================

.. c:function:: void *skb_frag_address_safe (const skb_frag_t *frag)

    gets the address of the data contained in a paged fragment

    :param const skb_frag_t \*frag:
        the paged fragment buffer



.. _`skb_frag_address_safe.description`:

Description
-----------

Returns the address of the data within ``frag``\ . Checks that the page
is mapped and returns ``NULL`` otherwise.



.. _`__skb_frag_set_page`:

__skb_frag_set_page
===================

.. c:function:: void __skb_frag_set_page (skb_frag_t *frag, struct page *page)

    sets the page contained in a paged fragment

    :param skb_frag_t \*frag:
        the paged fragment

    :param struct page \*page:
        the page to set



.. _`__skb_frag_set_page.description`:

Description
-----------

Sets the fragment ``frag`` to contain ``page``\ .



.. _`skb_frag_set_page`:

skb_frag_set_page
=================

.. c:function:: void skb_frag_set_page (struct sk_buff *skb, int f, struct page *page)

    sets the page contained in a paged fragment of an skb

    :param struct sk_buff \*skb:
        the buffer

    :param int f:
        the fragment offset

    :param struct page \*page:
        the page to set



.. _`skb_frag_set_page.description`:

Description
-----------

Sets the ``f``\ 'th fragment of ``skb`` to contain ``page``\ .



.. _`skb_frag_dma_map`:

skb_frag_dma_map
================

.. c:function:: dma_addr_t skb_frag_dma_map (struct device *dev, const skb_frag_t *frag, size_t offset, size_t size, enum dma_data_direction dir)

    maps a paged fragment via the DMA API

    :param struct device \*dev:
        the device to map the fragment to

    :param const skb_frag_t \*frag:
        the paged fragment to map

    :param size_t offset:
        the offset within the fragment (starting at the
        fragment's own offset)

    :param size_t size:
        the number of bytes to map

    :param enum dma_data_direction dir:
        the direction of the mapping (\ ``PCI_DMA_``\ \*)



.. _`skb_frag_dma_map.description`:

Description
-----------

Maps the page associated with ``frag`` to ``device``\ .



.. _`skb_clone_writable`:

skb_clone_writable
==================

.. c:function:: int skb_clone_writable (const struct sk_buff *skb, unsigned int len)

    is the header of a clone writable

    :param const struct sk_buff \*skb:
        buffer to check

    :param unsigned int len:
        length up to which to write



.. _`skb_clone_writable.description`:

Description
-----------

Returns true if modifying the header part of the cloned buffer
does not requires the data to be copied.



.. _`skb_cow`:

skb_cow
=======

.. c:function:: int skb_cow (struct sk_buff *skb, unsigned int headroom)

    copy header of skb when it is required

    :param struct sk_buff \*skb:
        buffer to cow

    :param unsigned int headroom:
        needed headroom



.. _`skb_cow.description`:

Description
-----------

If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.

The result is skb with writable area skb->head...skb->tail
and at least ``headroom`` of space at head.



.. _`skb_cow_head`:

skb_cow_head
============

.. c:function:: int skb_cow_head (struct sk_buff *skb, unsigned int headroom)

    skb_cow but only making the head writable

    :param struct sk_buff \*skb:
        buffer to cow

    :param unsigned int headroom:
        needed headroom



.. _`skb_cow_head.description`:

Description
-----------

This function is identical to skb_cow except that we replace the
skb_cloned check by skb_header_cloned.  It should be used when
you only need to push on some header and do not need to modify
the data.



.. _`skb_padto`:

skb_padto
=========

.. c:function:: int skb_padto (struct sk_buff *skb, unsigned int len)

    pad an skbuff up to a minimal size

    :param struct sk_buff \*skb:
        buffer to pad

    :param unsigned int len:
        minimal length



.. _`skb_padto.description`:

Description
-----------

Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.



.. _`skb_put_padto`:

skb_put_padto
=============

.. c:function:: int skb_put_padto (struct sk_buff *skb, unsigned int len)

    increase size and pad an skbuff up to a minimal size

    :param struct sk_buff \*skb:
        buffer to pad

    :param unsigned int len:
        minimal length



.. _`skb_put_padto.description`:

Description
-----------

Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.



.. _`skb_linearize`:

skb_linearize
=============

.. c:function:: int skb_linearize (struct sk_buff *skb)

    convert paged skb to linear one

    :param struct sk_buff \*skb:
        buffer to linarize



.. _`skb_linearize.description`:

Description
-----------

If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.



.. _`skb_has_shared_frag`:

skb_has_shared_frag
===================

.. c:function:: bool skb_has_shared_frag (const struct sk_buff *skb)

    can any frag be overwritten

    :param const struct sk_buff \*skb:
        buffer to test



.. _`skb_has_shared_frag.description`:

Description
-----------

Return true if the skb has at least one frag that might be modified
by an external entity (as in :c:func:`vmsplice`/:c:func:`sendfile`)



.. _`skb_linearize_cow`:

skb_linearize_cow
=================

.. c:function:: int skb_linearize_cow (struct sk_buff *skb)

    make sure skb is linear and writable

    :param struct sk_buff \*skb:
        buffer to process



.. _`skb_linearize_cow.description`:

Description
-----------

If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.



.. _`skb_postpull_rcsum`:

skb_postpull_rcsum
==================

.. c:function:: void skb_postpull_rcsum (struct sk_buff *skb, const void *start, unsigned int len)

    update checksum for received skb after pull

    :param struct sk_buff \*skb:
        buffer to update

    :param const void \*start:
        start of data before pull

    :param unsigned int len:
        length of data pulled



.. _`skb_postpull_rcsum.description`:

Description
-----------

After doing a pull on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum, or set ip_summed to
CHECKSUM_NONE so that it can be recomputed from scratch.



.. _`pskb_trim_rcsum`:

pskb_trim_rcsum
===============

.. c:function:: int pskb_trim_rcsum (struct sk_buff *skb, unsigned int len)

    trim received skb and update checksum

    :param struct sk_buff \*skb:
        buffer to trim

    :param unsigned int len:
        new length



.. _`pskb_trim_rcsum.description`:

Description
-----------

This is exactly the same as pskb_trim except that it ensures the
checksum of received packets are still valid after the operation.



.. _`skb_needs_linearize`:

skb_needs_linearize
===================

.. c:function:: bool skb_needs_linearize (struct sk_buff *skb, netdev_features_t features)

    check if we need to linearize a given skb depending on the given device features.

    :param struct sk_buff \*skb:
        socket buffer to check

    :param netdev_features_t features:
        net device features



.. _`skb_needs_linearize.returns-true-if-either`:

Returns true if either
----------------------

1. skb has frag_list and the device doesn't support FRAGLIST, or
2. skb is fragmented and the device does not support SG.



.. _`skb_get_timestamp`:

skb_get_timestamp
=================

.. c:function:: void skb_get_timestamp (const struct sk_buff *skb, struct timeval *stamp)

    get timestamp from a skb

    :param const struct sk_buff \*skb:
        skb to get stamp from

    :param struct timeval \*stamp:
        pointer to struct timeval to store stamp in



.. _`skb_get_timestamp.description`:

Description
-----------

Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.



.. _`skb_complete_tx_timestamp`:

skb_complete_tx_timestamp
=========================

.. c:function:: void skb_complete_tx_timestamp (struct sk_buff *skb, struct skb_shared_hwtstamps *hwtstamps)

    deliver cloned skb with tx timestamps

    :param struct sk_buff \*skb:
        clone of the the original outgoing packet

    :param struct skb_shared_hwtstamps \*hwtstamps:
        hardware time stamps



.. _`skb_complete_tx_timestamp.description`:

Description
-----------


PHY drivers may accept clones of transmitted packets for
timestamping via their phy_driver.txtstamp method. These drivers
must call this function to return the skb back to the stack with a
timestamp.



.. _`skb_tstamp_tx`:

skb_tstamp_tx
=============

.. c:function:: void skb_tstamp_tx (struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps)

    queue clone of skb with send time stamps

    :param struct sk_buff \*orig_skb:
        the original outgoing packet

    :param struct skb_shared_hwtstamps \*hwtstamps:
        hardware time stamps, may be NULL if not available



.. _`skb_tstamp_tx.description`:

Description
-----------

If the skb has a socket associated, then this function clones the
skb (thus sharing the actual data and optional structures), stores
the optional hardware time stamping information (if non NULL) or
generates a software time stamp (otherwise), then queues the clone
to the error queue of the socket.  Errors are silently ignored.



.. _`skb_tx_timestamp`:

skb_tx_timestamp
================

.. c:function:: void skb_tx_timestamp (struct sk_buff *skb)

    Driver hook for transmit timestamping

    :param struct sk_buff \*skb:
        A socket buffer.



.. _`skb_tx_timestamp.description`:

Description
-----------


Ethernet MAC Drivers should call this function in their :c:func:`hard_xmit`
function immediately before giving the sk_buff to the MAC hardware.

Specifically, one should make absolutely sure that this function is
called before TX completion of this packet can trigger.  Otherwise
the packet could potentially already be freed.



.. _`skb_complete_wifi_ack`:

skb_complete_wifi_ack
=====================

.. c:function:: void skb_complete_wifi_ack (struct sk_buff *skb, bool acked)

    deliver skb with wifi status

    :param struct sk_buff \*skb:
        the original outgoing packet

    :param bool acked:
        ack status



.. _`skb_checksum_complete`:

skb_checksum_complete
=====================

.. c:function:: __sum16 skb_checksum_complete (struct sk_buff *skb)

    Calculate checksum of an entire packet

    :param struct sk_buff \*skb:
        packet to process



.. _`skb_checksum_complete.description`:

Description
-----------

This function calculates the checksum over the entire packet plus
the value of skb->csum.  The latter can be used to supply the
checksum of a pseudo header as used by TCP/UDP.  It returns the
checksum.

For protocols that contain complete checksums such as ICMP/TCP/UDP,
this function can be used to verify that checksum on received
packets.  In that case the function should return zero if the
checksum is correct.  In particular, this function will return zero
if skb->ip_summed is CHECKSUM_UNNECESSARY which indicates that the
hardware has already verified the correctness of the checksum.



.. _`skb_checksum_none_assert`:

skb_checksum_none_assert
========================

.. c:function:: void skb_checksum_none_assert (const struct sk_buff *skb)

    make sure skb ip_summed is CHECKSUM_NONE

    :param const struct sk_buff \*skb:
        skb to check



.. _`skb_checksum_none_assert.description`:

Description
-----------

fresh skbs have their ip_summed set to CHECKSUM_NONE.
Instead of forcing ip_summed to CHECKSUM_NONE, we can
use this helper, to document places where we make this assertion.



.. _`skb_head_is_locked`:

skb_head_is_locked
==================

.. c:function:: bool skb_head_is_locked (const struct sk_buff *skb)

    Determine if the skb->head is locked down

    :param const struct sk_buff \*skb:
        skb to check



.. _`skb_head_is_locked.description`:

Description
-----------

The head on skbs build around a head frag can be removed if they are
not cloned.  This function returns true if the skb head is locked down
due to either being allocated via kmalloc, or by being a clone with
multiple references to the head.



.. _`skb_gso_network_seglen`:

skb_gso_network_seglen
======================

.. c:function:: unsigned int skb_gso_network_seglen (const struct sk_buff *skb)

    Return length of individual segments of a gso packet

    :param const struct sk_buff \*skb:
        GSO skb



.. _`skb_gso_network_seglen.description`:

Description
-----------

skb_gso_network_seglen is used to determine the real size of the
individual segments, including Layer3 (IP, IPv6) and L4 headers (TCP/UDP).

The MAC/L2 header is not accounted for.

