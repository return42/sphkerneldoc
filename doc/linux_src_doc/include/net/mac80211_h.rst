.. -*- coding: utf-8; mode: rst -*-
.. src-file: include/net/mac80211.h

.. _`ieee80211_max_queues`:

enum ieee80211_max_queues
=========================

.. c:type:: enum ieee80211_max_queues

    maximum number of queues

.. _`ieee80211_max_queues.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_max_queues {
        IEEE80211_MAX_QUEUES,
        IEEE80211_MAX_QUEUE_MAP
    };

.. _`ieee80211_max_queues.constants`:

Constants
---------

IEEE80211_MAX_QUEUES
    Maximum number of regular device queues.

IEEE80211_MAX_QUEUE_MAP
    bitmap with maximum queues set

.. _`ieee80211_ac_numbers`:

enum ieee80211_ac_numbers
=========================

.. c:type:: enum ieee80211_ac_numbers

    AC numbers as used in mac80211

.. _`ieee80211_ac_numbers.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_ac_numbers {
        IEEE80211_AC_VO,
        IEEE80211_AC_VI,
        IEEE80211_AC_BE,
        IEEE80211_AC_BK
    };

.. _`ieee80211_ac_numbers.constants`:

Constants
---------

IEEE80211_AC_VO
    voice

IEEE80211_AC_VI
    video

IEEE80211_AC_BE
    best effort

IEEE80211_AC_BK
    background

.. _`ieee80211_tx_queue_params`:

struct ieee80211_tx_queue_params
================================

.. c:type:: struct ieee80211_tx_queue_params

    transmit queue configuration

.. _`ieee80211_tx_queue_params.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tx_queue_params {
        u16 txop;
        u16 cw_min;
        u16 cw_max;
        u8 aifs;
        bool acm;
        bool uapsd;
    }

.. _`ieee80211_tx_queue_params.members`:

Members
-------

txop
    maximum burst time in units of 32 usecs, 0 meaning disabled

cw_min
    minimum contention window [a value of the form
    2^n-1 in the range 1..32767]

cw_max
    maximum contention window [like \ ``cw_min``\ ]

aifs
    arbitration interframe space [0..255]

acm
    is mandatory admission control required for the access category

uapsd
    is U-APSD mode enabled for the queue

.. _`ieee80211_tx_queue_params.description`:

Description
-----------

The information provided in this structure is required for QoS
transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.

.. _`ieee80211_chanctx_change`:

enum ieee80211_chanctx_change
=============================

.. c:type:: enum ieee80211_chanctx_change

    change flag for channel context

.. _`ieee80211_chanctx_change.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_chanctx_change {
        IEEE80211_CHANCTX_CHANGE_WIDTH,
        IEEE80211_CHANCTX_CHANGE_RX_CHAINS,
        IEEE80211_CHANCTX_CHANGE_RADAR,
        IEEE80211_CHANCTX_CHANGE_CHANNEL,
        IEEE80211_CHANCTX_CHANGE_MIN_WIDTH
    };

.. _`ieee80211_chanctx_change.constants`:

Constants
---------

IEEE80211_CHANCTX_CHANGE_WIDTH
    The channel width changed

IEEE80211_CHANCTX_CHANGE_RX_CHAINS
    The number of RX chains changed

IEEE80211_CHANCTX_CHANGE_RADAR
    radar detection flag changed

IEEE80211_CHANCTX_CHANGE_CHANNEL
    switched to another operating channel,
    this is used only with channel switching with CSA

IEEE80211_CHANCTX_CHANGE_MIN_WIDTH
    The min required channel width changed

.. _`ieee80211_chanctx_conf`:

struct ieee80211_chanctx_conf
=============================

.. c:type:: struct ieee80211_chanctx_conf

    channel context that vifs may be tuned to

.. _`ieee80211_chanctx_conf.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_chanctx_conf {
        struct cfg80211_chan_def def;
        struct cfg80211_chan_def min_def;
        u8 rx_chains_static;
        u8 rx_chains_dynamic;
        bool radar_enabled;
        u8 drv_priv[0];
    }

.. _`ieee80211_chanctx_conf.members`:

Members
-------

def
    the channel definition

min_def
    the minimum channel definition currently required.

rx_chains_static
    The number of RX chains that must always be
    active on the channel to receive MIMO transmissions

rx_chains_dynamic
    The number of RX chains that must be enabled
    after RTS/CTS handshake to receive SMPS MIMO transmissions;
    this will always be >= \ ``rx_chains_static``\ .

radar_enabled
    whether radar detection is enabled on this channel.

drv_priv
    data area for driver use, will always be aligned to
    sizeof(void \*), size is determined in hw information.

.. _`ieee80211_chanctx_conf.description`:

Description
-----------

This is the driver-visible part. The ieee80211_chanctx
that contains it is visible in mac80211 only.

.. _`ieee80211_chanctx_switch_mode`:

enum ieee80211_chanctx_switch_mode
==================================

.. c:type:: enum ieee80211_chanctx_switch_mode

    channel context switch mode

.. _`ieee80211_chanctx_switch_mode.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_chanctx_switch_mode {
        CHANCTX_SWMODE_REASSIGN_VIF,
        CHANCTX_SWMODE_SWAP_CONTEXTS
    };

.. _`ieee80211_chanctx_switch_mode.constants`:

Constants
---------

CHANCTX_SWMODE_REASSIGN_VIF
    Both old and new contexts already
    exist (and will continue to exist), but the virtual interface
    needs to be switched from one to the other.

CHANCTX_SWMODE_SWAP_CONTEXTS
    The old context exists but will stop
    to exist with this call, the new context doesn't exist but
    will be active after this call, the virtual interface switches
    from the old to the new (note that the driver may of course
    implement this as an on-the-fly chandef switch of the existing
    hardware context, but the mac80211 pointer for the old context
    will cease to exist and only the new one will later be used
    for changes/removal.)

.. _`ieee80211_vif_chanctx_switch`:

struct ieee80211_vif_chanctx_switch
===================================

.. c:type:: struct ieee80211_vif_chanctx_switch

    vif chanctx switch information

.. _`ieee80211_vif_chanctx_switch.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_vif_chanctx_switch {
        struct ieee80211_vif *vif;
        struct ieee80211_chanctx_conf *old_ctx;
        struct ieee80211_chanctx_conf *new_ctx;
    }

.. _`ieee80211_vif_chanctx_switch.members`:

Members
-------

vif
    the vif that should be switched from old_ctx to new_ctx

old_ctx
    the old context to which the vif was assigned

new_ctx
    the new context to which the vif must be assigned

.. _`ieee80211_vif_chanctx_switch.description`:

Description
-----------

This is structure is used to pass information about a vif that
needs to switch from one chanctx to another.  The
\ :c:type:`struct ieee80211_chanctx_switch_mode <ieee80211_chanctx_switch_mode>` defines how the switch should be
done.

.. _`ieee80211_bss_change`:

enum ieee80211_bss_change
=========================

.. c:type:: enum ieee80211_bss_change

    BSS change notification flags

.. _`ieee80211_bss_change.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_bss_change {
        BSS_CHANGED_ASSOC,
        BSS_CHANGED_ERP_CTS_PROT,
        BSS_CHANGED_ERP_PREAMBLE,
        BSS_CHANGED_ERP_SLOT,
        BSS_CHANGED_HT,
        BSS_CHANGED_BASIC_RATES,
        BSS_CHANGED_BEACON_INT,
        BSS_CHANGED_BSSID,
        BSS_CHANGED_BEACON,
        BSS_CHANGED_BEACON_ENABLED,
        BSS_CHANGED_CQM,
        BSS_CHANGED_IBSS,
        BSS_CHANGED_ARP_FILTER,
        BSS_CHANGED_QOS,
        BSS_CHANGED_IDLE,
        BSS_CHANGED_SSID,
        BSS_CHANGED_AP_PROBE_RESP,
        BSS_CHANGED_PS,
        BSS_CHANGED_TXPOWER,
        BSS_CHANGED_P2P_PS,
        BSS_CHANGED_BEACON_INFO,
        BSS_CHANGED_BANDWIDTH,
        BSS_CHANGED_OCB,
        BSS_CHANGED_MU_GROUPS
    };

.. _`ieee80211_bss_change.constants`:

Constants
---------

BSS_CHANGED_ASSOC
    association status changed (associated/disassociated),
    also implies a change in the AID.

BSS_CHANGED_ERP_CTS_PROT
    CTS protection changed

BSS_CHANGED_ERP_PREAMBLE
    preamble changed

BSS_CHANGED_ERP_SLOT
    slot timing changed

BSS_CHANGED_HT
    802.11n parameters changed

BSS_CHANGED_BASIC_RATES
    Basic rateset changed

BSS_CHANGED_BEACON_INT
    Beacon interval changed

BSS_CHANGED_BSSID
    BSSID changed, for whatever
    reason (IBSS and managed mode)

BSS_CHANGED_BEACON
    Beacon data changed, retrieve
    new beacon (beaconing modes)

BSS_CHANGED_BEACON_ENABLED
    Beaconing should be
    enabled/disabled (beaconing modes)

BSS_CHANGED_CQM
    Connection quality monitor config changed

BSS_CHANGED_IBSS
    IBSS join status changed

BSS_CHANGED_ARP_FILTER
    Hardware ARP filter address list or state changed.

BSS_CHANGED_QOS
    QoS for this association was enabled/disabled. Note
    that it is only ever disabled for station mode.

BSS_CHANGED_IDLE
    Idle changed for this BSS/interface.

BSS_CHANGED_SSID
    SSID changed for this BSS (AP and IBSS mode)

BSS_CHANGED_AP_PROBE_RESP
    Probe Response changed for this BSS (AP mode)

BSS_CHANGED_PS
    PS changed for this BSS (STA mode)

BSS_CHANGED_TXPOWER
    TX power setting changed for this interface

BSS_CHANGED_P2P_PS
    P2P powersave settings (CTWindow, opportunistic PS)
    changed

BSS_CHANGED_BEACON_INFO
    Data from the AP's beacon became available:
    currently dtim_period only is under consideration.

BSS_CHANGED_BANDWIDTH
    The bandwidth used by this interface changed,
    note that this is only called when it changes after the channel
    context had been assigned.

BSS_CHANGED_OCB
    OCB join status changed

BSS_CHANGED_MU_GROUPS
    VHT MU-MIMO group id or user position changed

.. _`ieee80211_bss_change.description`:

Description
-----------

These flags are used with the \ :c:func:`bss_info_changed`\  callback
to indicate which BSS parameter changed.

.. _`ieee80211_event_type`:

enum ieee80211_event_type
=========================

.. c:type:: enum ieee80211_event_type

    event to be notified to the low level driver

.. _`ieee80211_event_type.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_event_type {
        RSSI_EVENT,
        MLME_EVENT,
        BAR_RX_EVENT,
        BA_FRAME_TIMEOUT
    };

.. _`ieee80211_event_type.constants`:

Constants
---------

RSSI_EVENT
    AP's rssi crossed the a threshold set by the driver.

MLME_EVENT
    event related to MLME

BAR_RX_EVENT
    a BAR was received

BA_FRAME_TIMEOUT
    Frames were released from the reordering buffer because
    they timed out. This won't be called for each frame released, but only
    once each time the timeout triggers.

.. _`ieee80211_rssi_event_data`:

enum ieee80211_rssi_event_data
==============================

.. c:type:: enum ieee80211_rssi_event_data

    relevant when event type is \ ``RSSI_EVENT``\ 

.. _`ieee80211_rssi_event_data.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_rssi_event_data {
        RSSI_EVENT_HIGH,
        RSSI_EVENT_LOW
    };

.. _`ieee80211_rssi_event_data.constants`:

Constants
---------

RSSI_EVENT_HIGH
    AP's rssi went below the threshold set by the driver.

RSSI_EVENT_LOW
    AP's rssi went above the threshold set by the driver.

.. _`ieee80211_rssi_event`:

struct ieee80211_rssi_event
===========================

.. c:type:: struct ieee80211_rssi_event

    data attached to an \ ``RSSI_EVENT``\ 

.. _`ieee80211_rssi_event.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_rssi_event {
        enum ieee80211_rssi_event_data data;
    }

.. _`ieee80211_rssi_event.members`:

Members
-------

data
    See \ :c:type:`enum ieee80211_rssi_event_data <ieee80211_rssi_event_data>`\ 

.. _`ieee80211_mlme_event_data`:

enum ieee80211_mlme_event_data
==============================

.. c:type:: enum ieee80211_mlme_event_data

    relevant when event type is \ ``MLME_EVENT``\ 

.. _`ieee80211_mlme_event_data.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_mlme_event_data {
        AUTH_EVENT,
        ASSOC_EVENT,
        DEAUTH_RX_EVENT,
        DEAUTH_TX_EVENT
    };

.. _`ieee80211_mlme_event_data.constants`:

Constants
---------

AUTH_EVENT
    the MLME operation is authentication

ASSOC_EVENT
    the MLME operation is association

DEAUTH_RX_EVENT
    deauth received..

DEAUTH_TX_EVENT
    deauth sent.

.. _`ieee80211_mlme_event_status`:

enum ieee80211_mlme_event_status
================================

.. c:type:: enum ieee80211_mlme_event_status

    relevant when event type is \ ``MLME_EVENT``\ 

.. _`ieee80211_mlme_event_status.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_mlme_event_status {
        MLME_SUCCESS,
        MLME_DENIED,
        MLME_TIMEOUT
    };

.. _`ieee80211_mlme_event_status.constants`:

Constants
---------

MLME_SUCCESS
    the MLME operation completed successfully.

MLME_DENIED
    the MLME operation was denied by the peer.

MLME_TIMEOUT
    the MLME operation timed out.

.. _`ieee80211_mlme_event`:

struct ieee80211_mlme_event
===========================

.. c:type:: struct ieee80211_mlme_event

    data attached to an \ ``MLME_EVENT``\ 

.. _`ieee80211_mlme_event.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_mlme_event {
        enum ieee80211_mlme_event_data data;
        enum ieee80211_mlme_event_status status;
        u16 reason;
    }

.. _`ieee80211_mlme_event.members`:

Members
-------

data
    See \ :c:type:`enum ieee80211_mlme_event_data <ieee80211_mlme_event_data>`\ 

status
    See \ :c:type:`enum ieee80211_mlme_event_status <ieee80211_mlme_event_status>`\ 

reason
    the reason code if applicable

.. _`ieee80211_ba_event`:

struct ieee80211_ba_event
=========================

.. c:type:: struct ieee80211_ba_event

    data attached for BlockAck related events

.. _`ieee80211_ba_event.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_ba_event {
        struct ieee80211_sta *sta;
        u16 tid;
        u16 ssn;
    }

.. _`ieee80211_ba_event.members`:

Members
-------

sta
    pointer to the \ :c:type:`struct ieee80211_sta <ieee80211_sta>` to which this event relates

tid
    the tid

ssn
    the starting sequence number (for \ ``BAR_RX_EVENT``\ )

.. _`ieee80211_event`:

struct ieee80211_event
======================

.. c:type:: struct ieee80211_event

    event to be sent to the driver

.. _`ieee80211_event.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_event {
        enum ieee80211_event_type type;
        union u;
    }

.. _`ieee80211_event.members`:

Members
-------

type
    The event itself. See \ :c:type:`enum ieee80211_event_type <ieee80211_event_type>`\ .

u
    union holding the fields above

.. _`ieee80211_mu_group_data`:

struct ieee80211_mu_group_data
==============================

.. c:type:: struct ieee80211_mu_group_data

    STA's VHT MU-MIMO group data

.. _`ieee80211_mu_group_data.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_mu_group_data {
        u8 membership[WLAN_MEMBERSHIP_LEN];
        u8 position[WLAN_USER_POSITION_LEN];
    }

.. _`ieee80211_mu_group_data.members`:

Members
-------

membership
    64 bits array - a bit is set if station is member of the group

position
    2 bits per group id indicating the position in the group

.. _`ieee80211_mu_group_data.description`:

Description
-----------

This structure describes the group id data of VHT MU-MIMO

.. _`ieee80211_bss_conf`:

struct ieee80211_bss_conf
=========================

.. c:type:: struct ieee80211_bss_conf

    holds the BSS's changing parameters

.. _`ieee80211_bss_conf.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_bss_conf {
        const u8 *bssid;
        bool assoc;
        bool ibss_joined;
        bool ibss_creator;
        u16 aid;
        bool use_cts_prot;
        bool use_short_preamble;
        bool use_short_slot;
        bool enable_beacon;
        u8 dtim_period;
        u16 beacon_int;
        u16 assoc_capability;
        u64 sync_tsf;
        u32 sync_device_ts;
        u8 sync_dtim_count;
        u32 basic_rates;
        struct ieee80211_rate *beacon_rate;
        int mcast_rate[NUM_NL80211_BANDS];
        u16 ht_operation_mode;
        s32 cqm_rssi_thold;
        u32 cqm_rssi_hyst;
        struct cfg80211_chan_def chandef;
        struct ieee80211_mu_group_data mu_group;
        __be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];
        int arp_addr_cnt;
        bool qos;
        bool idle;
        bool ps;
        u8 ssid[IEEE80211_MAX_SSID_LEN];
        size_t ssid_len;
        bool hidden_ssid;
        int txpower;
        enum nl80211_tx_power_setting txpower_type;
        struct ieee80211_p2p_noa_attr p2p_noa_attr;
        bool allow_p2p_go_ps;
    }

.. _`ieee80211_bss_conf.members`:

Members
-------

bssid
    The BSSID for this BSS

assoc
    association status

ibss_joined
    indicates whether this station is part of an IBSS
    or not

ibss_creator
    indicates if a new IBSS network is being created

aid
    association ID number, valid only when \ ``assoc``\  is true

use_cts_prot
    use CTS protection

use_short_preamble
    use 802.11b short preamble

use_short_slot
    use short slot time (only relevant for ERP)

enable_beacon
    whether beaconing should be enabled or not

dtim_period
    num of beacons before the next DTIM, for beaconing,
    valid in station mode only if after the driver was notified
    with the \ ``BSS_CHANGED_BEACON_INFO``\  flag, will be non-zero then.

beacon_int
    beacon interval

assoc_capability
    capabilities taken from assoc resp

sync_tsf
    last beacon's/probe response's TSF timestamp (could be old
    as it may have been received during scanning long ago). If the
    HW flag \ ``IEEE80211_HW_TIMING_BEACON_ONLY``\  is set, then this can
    only come from a beacon, but might not become valid until after
    association when a beacon is received (which is notified with the
    \ ``BSS_CHANGED_DTIM``\  flag.). See also sync_dtim_count important notice.

sync_device_ts
    the device timestamp corresponding to the sync_tsf,
    the driver/device can use this to calculate synchronisation
    (see \ ``sync_tsf``\ ). See also sync_dtim_count important notice.

sync_dtim_count
    Only valid when \ ``IEEE80211_HW_TIMING_BEACON_ONLY``\ 
    is requested, see \ ``sync_tsf``\ /\ ``sync_device_ts``\ .

basic_rates
    bitmap of basic rates, each bit stands for an
    index into the rate table configured by the driver in
    the current band.

beacon_rate
    associated AP's beacon TX rate

mcast_rate
    per-band multicast rate index + 1 (0: disabled)

ht_operation_mode
    HT operation mode like in \ :c:type:`struct ieee80211_ht_operation <ieee80211_ht_operation>`\ .
    This field is only valid when the channel is a wide HT/VHT channel.
    Note that with TDLS this can be the case (channel is HT, protection must
    be used from this field) even when the BSS association isn't using HT.

cqm_rssi_thold
    Connection quality monitor RSSI threshold, a zero value
    implies disabled. As with the cfg80211 callback, a change here should
    cause an event to be sent indicating where the current value is in
    relation to the newly configured threshold.

cqm_rssi_hyst
    Connection quality monitor RSSI hysteresis

chandef
    Channel definition for this BSS -- the hardware might be
    configured a higher bandwidth than this BSS uses, for example.

mu_group
    VHT MU-MIMO group membership data

arp_addr_list
    List of IPv4 addresses for hardware ARP filtering. The
    may filter ARP queries targeted for other addresses than listed here.
    The driver must allow ARP queries targeted for all address listed here
    to pass through. An empty list implies no ARP queries need to pass.

arp_addr_cnt
    Number of addresses currently on the list. Note that this
    may be larger than \ ``IEEE80211_BSS_ARP_ADDR_LIST_LEN``\  (the arp_addr_list
    array size), it's up to the driver what to do in that case.

qos
    This is a QoS-enabled BSS.

idle
    This interface is idle. There's also a global idle flag in the
    hardware config which may be more appropriate depending on what
    your driver/device needs to do.

ps
    power-save mode (STA only). This flag is NOT affected by
    offchannel/dynamic_ps operations.

ssid
    The SSID of the current vif. Valid in AP and IBSS mode.

ssid_len
    Length of SSID given in \ ``ssid``\ .

hidden_ssid
    The SSID of the current vif is hidden. Only valid in AP-mode.

txpower
    TX power in dBm

txpower_type
    TX power adjustment used to control per packet Transmit
    Power Control (TPC) in lower driver for the current vif. In particular
    TPC is enabled if value passed in \ ``txpower_type``\  is
    NL80211_TX_POWER_LIMITED (allow using less than specified from
    userspace), whereas TPC is disabled if \ ``txpower_type``\  is set to
    NL80211_TX_POWER_FIXED (use value configured from userspace)

p2p_noa_attr
    P2P NoA attribute for P2P powersave

allow_p2p_go_ps
    indication for AP or P2P GO interface, whether it's allowed
    to use P2P PS mechanism or not. AP/P2P GO is not allowed to use P2P PS
    if it has associated clients without P2P PS support.

.. _`ieee80211_bss_conf.description`:

Description
-----------

This structure keeps information about a BSS (and an association
to that BSS) that can change during the lifetime of the BSS.

.. _`ieee80211_bss_conf.important`:

IMPORTANT
---------

These three sync\_\* parameters would possibly be out of sync
by the time the driver will use them. The synchronized view is currently
guaranteed only in certain callbacks.

.. _`mac80211_tx_info_flags`:

enum mac80211_tx_info_flags
===========================

.. c:type:: enum mac80211_tx_info_flags

    flags to describe transmission information/status

.. _`mac80211_tx_info_flags.definition`:

Definition
----------

.. code-block:: c

    enum mac80211_tx_info_flags {
        IEEE80211_TX_CTL_REQ_TX_STATUS,
        IEEE80211_TX_CTL_ASSIGN_SEQ,
        IEEE80211_TX_CTL_NO_ACK,
        IEEE80211_TX_CTL_CLEAR_PS_FILT,
        IEEE80211_TX_CTL_FIRST_FRAGMENT,
        IEEE80211_TX_CTL_SEND_AFTER_DTIM,
        IEEE80211_TX_CTL_AMPDU,
        IEEE80211_TX_CTL_INJECTED,
        IEEE80211_TX_STAT_TX_FILTERED,
        IEEE80211_TX_STAT_ACK,
        IEEE80211_TX_STAT_AMPDU,
        IEEE80211_TX_STAT_AMPDU_NO_BACK,
        IEEE80211_TX_CTL_RATE_CTRL_PROBE,
        IEEE80211_TX_INTFL_OFFCHAN_TX_OK,
        IEEE80211_TX_INTFL_NEED_TXPROCESSING,
        IEEE80211_TX_INTFL_RETRIED,
        IEEE80211_TX_INTFL_DONT_ENCRYPT,
        IEEE80211_TX_CTL_NO_PS_BUFFER,
        IEEE80211_TX_CTL_MORE_FRAMES,
        IEEE80211_TX_INTFL_RETRANSMISSION,
        IEEE80211_TX_INTFL_MLME_CONN_TX,
        IEEE80211_TX_INTFL_NL80211_FRAME_TX,
        IEEE80211_TX_CTL_LDPC,
        IEEE80211_TX_CTL_STBC,
        IEEE80211_TX_CTL_TX_OFFCHAN,
        IEEE80211_TX_INTFL_TKIP_MIC_FAILURE,
        IEEE80211_TX_CTL_NO_CCK_RATE,
        IEEE80211_TX_STATUS_EOSP,
        IEEE80211_TX_CTL_USE_MINRATE,
        IEEE80211_TX_CTL_DONTFRAG,
        IEEE80211_TX_STAT_NOACK_TRANSMITTED
    };

.. _`mac80211_tx_info_flags.constants`:

Constants
---------

IEEE80211_TX_CTL_REQ_TX_STATUS
    require TX status callback for this frame.

IEEE80211_TX_CTL_ASSIGN_SEQ
    The driver has to assign a sequence
    number to this frame, taking care of not overwriting the fragment
    number and increasing the sequence number only when the
    IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
    assign sequence numbers to QoS-data frames but cannot do so correctly
    for non-QoS-data and management frames because beacons need them from
    that counter as well and mac80211 cannot guarantee proper sequencing.
    If this flag is set, the driver should instruct the hardware to
    assign a sequence number to the frame or assign one itself. Cf. IEEE
    802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
    beacons and always be clear for frames without a sequence number field.

IEEE80211_TX_CTL_NO_ACK
    tell the low level not to wait for an ack

IEEE80211_TX_CTL_CLEAR_PS_FILT
    clear powersave filter for destination
    station

IEEE80211_TX_CTL_FIRST_FRAGMENT
    this is a first fragment of the frame

IEEE80211_TX_CTL_SEND_AFTER_DTIM
    send this frame after DTIM beacon

IEEE80211_TX_CTL_AMPDU
    this frame should be sent as part of an A-MPDU

IEEE80211_TX_CTL_INJECTED
    Frame was injected, internal to mac80211.

IEEE80211_TX_STAT_TX_FILTERED
    The frame was not transmitted
    because the destination STA was in powersave mode. Note that to
    avoid race conditions, the filter must be set by the hardware or
    firmware upon receiving a frame that indicates that the station
    went to sleep (must be done on device to filter frames already on
    the queue) and may only be unset after mac80211 gives the OK for
    that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
    since only then is it guaranteed that no more frames are in the
    hardware queue.

IEEE80211_TX_STAT_ACK
    Frame was acknowledged

IEEE80211_TX_STAT_AMPDU
    The frame was aggregated, so status
    is for the whole aggregation.

IEEE80211_TX_STAT_AMPDU_NO_BACK
    no block ack was returned,
    so consider using block ack request (BAR).

IEEE80211_TX_CTL_RATE_CTRL_PROBE
    internal to mac80211, can be
    set by rate control algorithms to indicate probe rate, will
    be cleared for fragmented frames (except on the last fragment)

IEEE80211_TX_INTFL_OFFCHAN_TX_OK
    Internal to mac80211. Used to indicate
    that a frame can be transmitted while the queues are stopped for
    off-channel operation.

IEEE80211_TX_INTFL_NEED_TXPROCESSING
    completely internal to mac80211,
    used to indicate that a pending frame requires TX processing before
    it can be sent out.

IEEE80211_TX_INTFL_RETRIED
    completely internal to mac80211,
    used to indicate that a frame was already retried due to PS

IEEE80211_TX_INTFL_DONT_ENCRYPT
    completely internal to mac80211,
    used to indicate frame should not be encrypted

IEEE80211_TX_CTL_NO_PS_BUFFER
    This frame is a response to a poll
    frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
    be sent although the station is in powersave mode.

IEEE80211_TX_CTL_MORE_FRAMES
    More frames will be passed to the
    transmit function after the current frame, this can be used
    by drivers to kick the DMA queue only if unset or when the
    queue gets full.

IEEE80211_TX_INTFL_RETRANSMISSION
    This frame is being retransmitted
    after TX status because the destination was asleep, it must not
    be modified again (no seqno assignment, crypto, etc.)

IEEE80211_TX_INTFL_MLME_CONN_TX
    This frame was transmitted by the MLME
    code for connection establishment, this indicates that its status
    should kick the MLME state machine.

IEEE80211_TX_INTFL_NL80211_FRAME_TX
    Frame was requested through nl80211
    MLME command (internal to mac80211 to figure out whether to send TX
    status to user space)

IEEE80211_TX_CTL_LDPC
    tells the driver to use LDPC for this frame

IEEE80211_TX_CTL_STBC
    Enables Space-Time Block Coding (STBC) for this
    frame and selects the maximum number of streams that it can use.

IEEE80211_TX_CTL_TX_OFFCHAN
    Marks this packet to be transmitted on
    the off-channel channel when a remain-on-channel offload is done
    in hardware -- normal packets still flow and are expected to be
    handled properly by the device.

IEEE80211_TX_INTFL_TKIP_MIC_FAILURE
    Marks this packet to be used for TKIP
    testing. It will be sent out with incorrect Michael MIC key to allow
    TKIP countermeasures to be tested.

IEEE80211_TX_CTL_NO_CCK_RATE
    This frame will be sent at non CCK rate.
    This flag is actually used for management frame especially for P2P
    frames not being sent at CCK rate in 2GHz band.

IEEE80211_TX_STATUS_EOSP
    This packet marks the end of service period,
    when its status is reported the service period ends. For frames in
    an SP that mac80211 transmits, it is already set; for driver frames
    the driver may set this flag. It is also used to do the same for
    PS-Poll responses.

IEEE80211_TX_CTL_USE_MINRATE
    This frame will be sent at lowest rate.
    This flag is used to send nullfunc frame at minimum rate when
    the nullfunc is used for connection monitoring purpose.

IEEE80211_TX_CTL_DONTFRAG
    Don't fragment this packet even if it
    would be fragmented by size (this is optional, only used for
    monitor injection).

IEEE80211_TX_STAT_NOACK_TRANSMITTED
    A frame that was marked with
    IEEE80211_TX_CTL_NO_ACK has been successfully transmitted without
    any errors (like issues specific to the driver/HW).
    This flag must not be set for frames that don't request no-ack
    behaviour with IEEE80211_TX_CTL_NO_ACK.

.. _`mac80211_tx_info_flags.description`:

Description
-----------

These flags are used with the \ ``flags``\  member of \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`.

.. _`mac80211_tx_info_flags.note`:

Note
----

If you have to add new flags to the enumeration, then don't
forget to update \ ``IEEE80211_TX_TEMPORARY_FLAGS``\  when necessary.

.. _`mac80211_tx_control_flags`:

enum mac80211_tx_control_flags
==============================

.. c:type:: enum mac80211_tx_control_flags

    flags to describe transmit control

.. _`mac80211_tx_control_flags.definition`:

Definition
----------

.. code-block:: c

    enum mac80211_tx_control_flags {
        IEEE80211_TX_CTRL_PORT_CTRL_PROTO,
        IEEE80211_TX_CTRL_PS_RESPONSE,
        IEEE80211_TX_CTRL_RATE_INJECT,
        IEEE80211_TX_CTRL_AMSDU
    };

.. _`mac80211_tx_control_flags.constants`:

Constants
---------

IEEE80211_TX_CTRL_PORT_CTRL_PROTO
    this frame is a port control
    protocol frame (e.g. EAP)

IEEE80211_TX_CTRL_PS_RESPONSE
    This frame is a response to a poll
    frame (PS-Poll or uAPSD).

IEEE80211_TX_CTRL_RATE_INJECT
    This frame is injected with rate information

IEEE80211_TX_CTRL_AMSDU
    This frame is an A-MSDU frame

.. _`mac80211_tx_control_flags.description`:

Description
-----------

These flags are used in tx_info->control.flags.

.. _`mac80211_rate_control_flags`:

enum mac80211_rate_control_flags
================================

.. c:type:: enum mac80211_rate_control_flags

    per-rate flags set by the Rate Control algorithm.

.. _`mac80211_rate_control_flags.definition`:

Definition
----------

.. code-block:: c

    enum mac80211_rate_control_flags {
        IEEE80211_TX_RC_USE_RTS_CTS,
        IEEE80211_TX_RC_USE_CTS_PROTECT,
        IEEE80211_TX_RC_USE_SHORT_PREAMBLE,
        IEEE80211_TX_RC_MCS,
        IEEE80211_TX_RC_GREEN_FIELD,
        IEEE80211_TX_RC_40_MHZ_WIDTH,
        IEEE80211_TX_RC_DUP_DATA,
        IEEE80211_TX_RC_SHORT_GI,
        IEEE80211_TX_RC_VHT_MCS,
        IEEE80211_TX_RC_80_MHZ_WIDTH,
        IEEE80211_TX_RC_160_MHZ_WIDTH
    };

.. _`mac80211_rate_control_flags.constants`:

Constants
---------

IEEE80211_TX_RC_USE_RTS_CTS
    Use RTS/CTS exchange for this rate.

IEEE80211_TX_RC_USE_CTS_PROTECT
    CTS-to-self protection is required.
    This is set if the current BSS requires ERP protection.

IEEE80211_TX_RC_USE_SHORT_PREAMBLE
    Use short preamble.

IEEE80211_TX_RC_MCS
    HT rate.

IEEE80211_TX_RC_GREEN_FIELD
    Indicates whether this rate should be used in
    Greenfield mode.

IEEE80211_TX_RC_40_MHZ_WIDTH
    Indicates if the Channel Width should be 40 MHz.

IEEE80211_TX_RC_DUP_DATA
    The frame should be transmitted on both of the
    adjacent 20 MHz channels, if the current channel type is
    NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.

IEEE80211_TX_RC_SHORT_GI
    Short Guard interval should be used for this rate.

IEEE80211_TX_RC_VHT_MCS
    VHT MCS rate, in this case the idx field is split
    into a higher 4 bits (Nss) and lower 4 bits (MCS number)

IEEE80211_TX_RC_80_MHZ_WIDTH
    Indicates 80 MHz transmission

IEEE80211_TX_RC_160_MHZ_WIDTH
    Indicates 160 MHz transmission
    (80+80 isn't supported yet)

.. _`mac80211_rate_control_flags.description`:

Description
-----------

These flags are set by the Rate control algorithm for each rate during tx,
in the \ ``flags``\  member of struct ieee80211_tx_rate.

.. _`ieee80211_tx_rate`:

struct ieee80211_tx_rate
========================

.. c:type:: struct ieee80211_tx_rate

    rate selection/status

.. _`ieee80211_tx_rate.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tx_rate {
        s8 idx;
        u16 count:5;
        u16 flags:5:11;
    }

.. _`ieee80211_tx_rate.members`:

Members
-------

idx
    rate index to attempt to send with

count
    number of tries in this rate before going to the next rate

flags
    rate control flags (\ :c:type:`enum mac80211_rate_control_flags <mac80211_rate_control_flags>`\ )

.. _`ieee80211_tx_rate.description`:

Description
-----------

A value of -1 for \ ``idx``\  indicates an invalid rate and, if used
in an array of retry rates, that no more rates should be tried.

When used for transmit status reporting, the driver should
always report the rate along with the flags it used.

\ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  contains an array of these structs
in the control information, and it will be filled by the rate
control algorithm according to what should be sent. For example,
if this array contains, in the format { <idx>, <count> } the
information
{ 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
then this means that the frame should be transmitted
up to twice at rate 3, up to twice at rate 2, and up to four
times at rate 1 if it doesn't get acknowledged. Say it gets
acknowledged by the peer after the fifth attempt, the status
information should then contain
{ 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
since it was transmitted twice at rate 3, twice at rate 2
and once at rate 1 after which we received an acknowledgement.

.. _`ieee80211_tx_info`:

struct ieee80211_tx_info
========================

.. c:type:: struct ieee80211_tx_info

    skb transmit information

.. _`ieee80211_tx_info.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tx_info {
        u32 flags;
        u8 band;
        u8 hw_queue;
        u16 ack_frame_id;
        union {unnamed_union};
    }

.. _`ieee80211_tx_info.members`:

Members
-------

flags
    transmit info flags, defined above

band
    the band to transmit on (use for checking for races)

hw_queue
    HW queue to put the frame on, \ :c:func:`skb_get_queue_mapping`\  gives the AC

ack_frame_id
    internal frame ID for TX status, used internally

{unnamed_union}
    anonymous


.. _`ieee80211_tx_info.description`:

Description
-----------

This structure is placed in skb->cb for three uses:
(1) mac80211 TX control - mac80211 tells the driver what to do
(2) driver internal use (if applicable)
(3) TX status information - driver tells mac80211 what happened

.. _`ieee80211_scan_ies`:

struct ieee80211_scan_ies
=========================

.. c:type:: struct ieee80211_scan_ies

    descriptors for different blocks of IEs

.. _`ieee80211_scan_ies.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_scan_ies {
        const u8  *ies[NUM_NL80211_BANDS];
        size_t len[NUM_NL80211_BANDS];
        const u8 *common_ies;
        size_t common_ie_len;
    }

.. _`ieee80211_scan_ies.members`:

Members
-------

ies
    pointers to band specific IEs.

len
    lengths of band_specific IEs.

common_ies
    IEs for all bands (especially vendor specific ones)

common_ie_len
    length of the common_ies

.. _`ieee80211_scan_ies.description`:

Description
-----------

This structure is used to point to different blocks of IEs in HW scan
and scheduled scan. These blocks contain the IEs passed by userspace
and the ones generated by mac80211.

.. _`ieee80211_tx_info_clear_status`:

ieee80211_tx_info_clear_status
==============================

.. c:function:: void ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)

    clear TX status

    :param struct ieee80211_tx_info \*info:
        The \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  to be cleared.

.. _`ieee80211_tx_info_clear_status.description`:

Description
-----------

When the driver passes an skb back to mac80211, it must report
a number of things in TX status. This function clears everything
in the TX status but the rate control information (it does clear
the count since you need to fill that in anyway).

.. _`ieee80211_tx_info_clear_status.note`:

NOTE
----

You can only use this function if you do NOT use
info->driver_data! Use info->rate_driver_data
instead if you need only the less space that allows.

.. _`mac80211_rx_flags`:

enum mac80211_rx_flags
======================

.. c:type:: enum mac80211_rx_flags

    receive flags

.. _`mac80211_rx_flags.definition`:

Definition
----------

.. code-block:: c

    enum mac80211_rx_flags {
        RX_FLAG_MMIC_ERROR,
        RX_FLAG_DECRYPTED,
        RX_FLAG_MACTIME_PLCP_START,
        RX_FLAG_MMIC_STRIPPED,
        RX_FLAG_IV_STRIPPED,
        RX_FLAG_FAILED_FCS_CRC,
        RX_FLAG_FAILED_PLCP_CRC,
        RX_FLAG_MACTIME_START,
        RX_FLAG_SHORTPRE,
        RX_FLAG_HT,
        RX_FLAG_40MHZ,
        RX_FLAG_SHORT_GI,
        RX_FLAG_NO_SIGNAL_VAL,
        RX_FLAG_HT_GF,
        RX_FLAG_AMPDU_DETAILS,
        RX_FLAG_PN_VALIDATED,
        RX_FLAG_DUP_VALIDATED,
        RX_FLAG_AMPDU_LAST_KNOWN,
        RX_FLAG_AMPDU_IS_LAST,
        RX_FLAG_AMPDU_DELIM_CRC_ERROR,
        RX_FLAG_AMPDU_DELIM_CRC_KNOWN,
        RX_FLAG_MACTIME_END,
        RX_FLAG_VHT,
        RX_FLAG_LDPC,
        RX_FLAG_ONLY_MONITOR,
        RX_FLAG_SKIP_MONITOR,
        RX_FLAG_STBC_MASK,
        RX_FLAG_10MHZ,
        RX_FLAG_5MHZ,
        RX_FLAG_AMSDU_MORE,
        RX_FLAG_RADIOTAP_VENDOR_DATA,
        RX_FLAG_MIC_STRIPPED,
        RX_FLAG_ALLOW_SAME_PN
    };

.. _`mac80211_rx_flags.constants`:

Constants
---------

RX_FLAG_MMIC_ERROR
    Michael MIC error was reported on this frame.
    Use together with \ ``RX_FLAG_MMIC_STRIPPED``\ .

RX_FLAG_DECRYPTED
    This frame was decrypted in hardware.

RX_FLAG_MACTIME_PLCP_START
    The timestamp passed in the RX status (\ ``mactime``\ 
    field) is valid and contains the time the SYNC preamble was received.

RX_FLAG_MMIC_STRIPPED
    the Michael MIC is stripped off this frame,
    verification has been done by the hardware.

RX_FLAG_IV_STRIPPED
    The IV/ICV are stripped from this frame.
    If this flag is set, the stack cannot do any replay detection
    hence the driver or hardware will have to do that.

RX_FLAG_FAILED_FCS_CRC
    Set this flag if the FCS check failed on
    the frame.

RX_FLAG_FAILED_PLCP_CRC
    Set this flag if the PCLP check failed on
    the frame.

RX_FLAG_MACTIME_START
    The timestamp passed in the RX status (\ ``mactime``\ 
    field) is valid and contains the time the first symbol of the MPDU
    was received. This is useful in monitor mode and for proper IBSS
    merging.

RX_FLAG_SHORTPRE
    Short preamble was used for this frame

RX_FLAG_HT
    HT MCS was used and rate_idx is MCS index

RX_FLAG_40MHZ
    HT40 (40 MHz) was used

RX_FLAG_SHORT_GI
    Short guard interval was used

RX_FLAG_NO_SIGNAL_VAL
    The signal strength value is not present.
    Valid only for data frames (mainly A-MPDU)

RX_FLAG_HT_GF
    This frame was received in a HT-greenfield transmission, if
    the driver fills this value it should add \ ``IEEE80211_RADIOTAP_MCS_HAVE_FMT``\ 
    to hw.radiotap_mcs_details to advertise that fact

RX_FLAG_AMPDU_DETAILS
    A-MPDU details are known, in particular the reference
    number (\ ``ampdu_reference``\ ) must be populated and be a distinct number for
    each A-MPDU

RX_FLAG_PN_VALIDATED
    Currently only valid for CCMP/GCMP frames, this
    flag indicates that the PN was verified for replay protection.
    Note that this flag is also currently only supported when a frame
    is also decrypted (ie. \ ``RX_FLAG_DECRYPTED``\  must be set)

RX_FLAG_DUP_VALIDATED
    The driver should set this flag if it did
    de-duplication by itself.

RX_FLAG_AMPDU_LAST_KNOWN
    last subframe is known, should be set on all
    subframes of a single A-MPDU

RX_FLAG_AMPDU_IS_LAST
    this subframe is the last subframe of the A-MPDU

RX_FLAG_AMPDU_DELIM_CRC_ERROR
    A delimiter CRC error has been detected
    on this subframe

RX_FLAG_AMPDU_DELIM_CRC_KNOWN
    The delimiter CRC field is known (the CRC
    is stored in the \ ``ampdu_delimiter_crc``\  field)

RX_FLAG_MACTIME_END
    The timestamp passed in the RX status (\ ``mactime``\ 
    field) is valid and contains the time the last symbol of the MPDU
    (including FCS) was received.

RX_FLAG_VHT
    VHT MCS was used and rate_index is MCS index

RX_FLAG_LDPC
    LDPC was used

RX_FLAG_ONLY_MONITOR
    Report frame only to monitor interfaces without
    processing it in any regular way.
    This is useful if drivers offload some frames but still want to report
    them for sniffing purposes.

RX_FLAG_SKIP_MONITOR
    Process and report frame to all interfaces except
    monitor interfaces.
    This is useful if drivers offload some frames but still want to report
    them for sniffing purposes.

RX_FLAG_STBC_MASK
    STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3

RX_FLAG_10MHZ
    10 MHz (half channel) was used

RX_FLAG_5MHZ
    5 MHz (quarter channel) was used

RX_FLAG_AMSDU_MORE
    Some drivers may prefer to report separate A-MSDU
    subframes instead of a one huge frame for performance reasons.
    All, but the last MSDU from an A-MSDU should have this flag set. E.g.
    if an A-MSDU has 3 frames, the first 2 must have the flag set, while
    the 3rd (last) one must not have this flag set. The flag is used to
    deal with retransmission/duplication recovery properly since A-MSDU
    subframes share the same sequence number. Reported subframes can be
    either regular MSDU or singly A-MSDUs. Subframes must not be
    interleaved with other frames.

RX_FLAG_RADIOTAP_VENDOR_DATA
    This frame contains vendor-specific
    radiotap data in the skb->data (before the frame) as described by
    the \ :c:type:`struct ieee80211_vendor_radiotap <ieee80211_vendor_radiotap>`\ .

RX_FLAG_MIC_STRIPPED
    The mic was stripped of this packet. Decryption was
    done by the hardware

RX_FLAG_ALLOW_SAME_PN
    Allow the same PN as same packet before.
    This is used for AMSDU subframes which can have the same PN as
    the first subframe.

.. _`mac80211_rx_flags.description`:

Description
-----------

These flags are used with the \ ``flag``\  member of \ :c:type:`struct ieee80211_rx_status <ieee80211_rx_status>`\ .

.. _`mac80211_rx_vht_flags`:

enum mac80211_rx_vht_flags
==========================

.. c:type:: enum mac80211_rx_vht_flags

    receive VHT flags

.. _`mac80211_rx_vht_flags.definition`:

Definition
----------

.. code-block:: c

    enum mac80211_rx_vht_flags {
        RX_VHT_FLAG_80MHZ,
        RX_VHT_FLAG_160MHZ,
        RX_VHT_FLAG_BF
    };

.. _`mac80211_rx_vht_flags.constants`:

Constants
---------

RX_VHT_FLAG_80MHZ
    80 MHz was used

RX_VHT_FLAG_160MHZ
    160 MHz was used

RX_VHT_FLAG_BF
    packet was beamformed

.. _`mac80211_rx_vht_flags.description`:

Description
-----------

These flags are used with the \ ``vht_flag``\  member of
\ :c:type:`struct ieee80211_rx_status <ieee80211_rx_status>`\ .

.. _`ieee80211_rx_status`:

struct ieee80211_rx_status
==========================

.. c:type:: struct ieee80211_rx_status

    receive status

.. _`ieee80211_rx_status.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_rx_status {
        u64 mactime;
        u64 boottime_ns;
        u32 device_timestamp;
        u32 ampdu_reference;
        u64 flag;
        u16 freq;
        u8 vht_flag;
        u8 rate_idx;
        u8 vht_nss;
        u8 rx_flags;
        u8 band;
        u8 antenna;
        s8 signal;
        u8 chains;
        s8 chain_signal[IEEE80211_MAX_CHAINS];
        u8 ampdu_delimiter_crc;
    }

.. _`ieee80211_rx_status.members`:

Members
-------

mactime
    value in microseconds of the 64-bit Time Synchronization Function
    (TSF) timer when the first data symbol (MPDU) arrived at the hardware.

boottime_ns
    CLOCK_BOOTTIME timestamp the frame was received at, this is
    needed only for beacons and probe responses that update the scan cache.

device_timestamp
    arbitrary timestamp for the device, mac80211 doesn't use
    it but can store it and pass it back to the driver for synchronisation

ampdu_reference
    A-MPDU reference number, must be a different value for
    each A-MPDU but the same for each subframe within one A-MPDU

flag
    \ ``RX_FLAG``\ \_\*

freq
    frequency the radio was tuned to when receiving this frame, in MHz
    This field must be set for management frames, but isn't strictly needed
    for data (other) frames - for those it only affects radiotap reporting.

vht_flag
    \ ``RX_VHT_FLAG``\ \_\*

rate_idx
    index of data rate into band's supported rates or MCS index if
    HT or VHT is used (\ ``RX_FLAG_HT``\ /\ ``RX_FLAG_VHT``\ )

vht_nss
    number of streams (VHT only)

rx_flags
    internal RX flags for mac80211

band
    the active band when this frame was received

antenna
    antenna used

signal
    signal strength when receiving this frame, either in dBm, in dB or
    unspecified depending on the hardware capabilities flags
    \ ``IEEE80211_HW_SIGNAL``\ \_\*

chains
    bitmask of receive chains for which separate signal strength
    values were filled.

chain_signal
    per-chain signal strength, in dBm (unlike \ ``signal``\ , doesn't
    support dB or unspecified units)

ampdu_delimiter_crc
    A-MPDU delimiter CRC

.. _`ieee80211_rx_status.description`:

Description
-----------

The low-level driver should provide this information (the subset
supported by hardware) to the 802.11 code with each received
frame, in the skb's control buffer (cb).

.. _`ieee80211_vendor_radiotap`:

struct ieee80211_vendor_radiotap
================================

.. c:type:: struct ieee80211_vendor_radiotap

    vendor radiotap data information

.. _`ieee80211_vendor_radiotap.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_vendor_radiotap {
        u32 present;
        u8 align;
        u8 oui[3];
        u8 subns;
        u8 pad;
        u16 len;
        u8 data[];
    }

.. _`ieee80211_vendor_radiotap.members`:

Members
-------

present
    presence bitmap for this vendor namespace
    (this could be extended in the future if any vendor needs more
    bits, the radiotap spec does allow for that)

align
    radiotap vendor namespace alignment. This defines the needed
    alignment for the \ ``data``\  field below, not for the vendor namespace
    description itself (which has a fixed 2-byte alignment)
    Must be a power of two, and be set to at least 1!

oui
    radiotap vendor namespace OUI

subns
    radiotap vendor sub namespace

pad
    number of bytes of padding after the \ ``data``\ , this exists so that
    the skb data alignment can be preserved even if the data has odd
    length

len
    radiotap vendor sub namespace skip length, if alignment is done
    then that's added to this, i.e. this is only the length of the
    \ ``data``\  field.

data
    the actual vendor namespace data

.. _`ieee80211_vendor_radiotap.description`:

Description
-----------

This struct, including the vendor data, goes into the skb->data before
the 802.11 header. It's split up in mac80211 using the align/oui/subns
data.

.. _`ieee80211_conf_flags`:

enum ieee80211_conf_flags
=========================

.. c:type:: enum ieee80211_conf_flags

    configuration flags

.. _`ieee80211_conf_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_conf_flags {
        IEEE80211_CONF_MONITOR,
        IEEE80211_CONF_PS,
        IEEE80211_CONF_IDLE,
        IEEE80211_CONF_OFFCHANNEL
    };

.. _`ieee80211_conf_flags.constants`:

Constants
---------

IEEE80211_CONF_MONITOR
    there's a monitor interface present -- use this
    to determine for example whether to calculate timestamps for packets
    or not, do not use instead of filter flags!

IEEE80211_CONF_PS
    Enable 802.11 power save mode (managed mode only).
    This is the power save mode defined by IEEE 802.11-2007 section 11.2,
    meaning that the hardware still wakes up for beacons, is able to
    transmit frames and receive the possible acknowledgment frames.
    Not to be confused with hardware specific wakeup/sleep states,
    driver is responsible for that. See the section "Powersave support"
    for more.

IEEE80211_CONF_IDLE
    The device is running, but idle; if the flag is set
    the driver should be prepared to handle configuration requests but
    may turn the device off as much as possible. Typically, this flag will
    be set when an interface is set UP but not associated or scanning, but
    it can also be unset in that case when monitor interfaces are active.

IEEE80211_CONF_OFFCHANNEL
    The device is currently not on its main
    operating channel.

.. _`ieee80211_conf_flags.description`:

Description
-----------

Flags to define PHY configuration options

.. _`ieee80211_conf_changed`:

enum ieee80211_conf_changed
===========================

.. c:type:: enum ieee80211_conf_changed

    denotes which configuration changed

.. _`ieee80211_conf_changed.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_conf_changed {
        IEEE80211_CONF_CHANGE_SMPS,
        IEEE80211_CONF_CHANGE_LISTEN_INTERVAL,
        IEEE80211_CONF_CHANGE_MONITOR,
        IEEE80211_CONF_CHANGE_PS,
        IEEE80211_CONF_CHANGE_POWER,
        IEEE80211_CONF_CHANGE_CHANNEL,
        IEEE80211_CONF_CHANGE_RETRY_LIMITS,
        IEEE80211_CONF_CHANGE_IDLE
    };

.. _`ieee80211_conf_changed.constants`:

Constants
---------

IEEE80211_CONF_CHANGE_SMPS
    Spatial multiplexing powersave mode changed
    Note that this is only valid if channel contexts are not used,
    otherwise each channel context has the number of chains listed.

IEEE80211_CONF_CHANGE_LISTEN_INTERVAL
    the listen interval changed

IEEE80211_CONF_CHANGE_MONITOR
    the monitor flag changed

IEEE80211_CONF_CHANGE_PS
    the PS flag or dynamic PS timeout changed

IEEE80211_CONF_CHANGE_POWER
    the TX power changed

IEEE80211_CONF_CHANGE_CHANNEL
    the channel/channel_type changed

IEEE80211_CONF_CHANGE_RETRY_LIMITS
    retry limits changed

IEEE80211_CONF_CHANGE_IDLE
    Idle flag changed

.. _`ieee80211_smps_mode`:

enum ieee80211_smps_mode
========================

.. c:type:: enum ieee80211_smps_mode

    spatial multiplexing power save mode

.. _`ieee80211_smps_mode.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_smps_mode {
        IEEE80211_SMPS_AUTOMATIC,
        IEEE80211_SMPS_OFF,
        IEEE80211_SMPS_STATIC,
        IEEE80211_SMPS_DYNAMIC,
        IEEE80211_SMPS_NUM_MODES
    };

.. _`ieee80211_smps_mode.constants`:

Constants
---------

IEEE80211_SMPS_AUTOMATIC
    automatic

IEEE80211_SMPS_OFF
    off

IEEE80211_SMPS_STATIC
    static

IEEE80211_SMPS_DYNAMIC
    dynamic

IEEE80211_SMPS_NUM_MODES
    internal, don't use

.. _`ieee80211_conf`:

struct ieee80211_conf
=====================

.. c:type:: struct ieee80211_conf

    configuration of the device

.. _`ieee80211_conf.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_conf {
        u32 flags;
        int power_level;
        int dynamic_ps_timeout;
        u16 listen_interval;
        u8 ps_dtim_period;
        u8 long_frame_max_tx_count;
        u8 short_frame_max_tx_count;
        struct cfg80211_chan_def chandef;
        bool radar_enabled;
        enum ieee80211_smps_mode smps_mode;
    }

.. _`ieee80211_conf.members`:

Members
-------

flags
    configuration flags defined above

power_level
    requested transmit power (in dBm), backward compatibility
    value only that is set to the minimum of all interfaces

dynamic_ps_timeout
    The dynamic powersave timeout (in ms), see the
    powersave documentation below. This variable is valid only when
    the CONF_PS flag is set.

listen_interval
    listen interval in units of beacon interval

ps_dtim_period
    The DTIM period of the AP we're connected to, for use
    in power saving. Power saving will not be enabled until a beacon
    has been received and the DTIM period is known.

long_frame_max_tx_count
    Maximum number of transmissions for a "long" frame
    (a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
    but actually means the number of transmissions not the number of retries

short_frame_max_tx_count
    Maximum number of transmissions for a "short"
    frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
    number of transmissions not the number of retries

chandef
    the channel definition to tune to

radar_enabled
    whether radar detection is enabled

smps_mode
    spatial multiplexing powersave mode; note that
    \ ``IEEE80211_SMPS_STATIC``\  is used when the device is not
    configured for an HT channel.
    Note that this is only valid if channel contexts are not used,
    otherwise each channel context has the number of chains listed.

.. _`ieee80211_conf.description`:

Description
-----------

This struct indicates how the driver shall configure the hardware.

.. _`ieee80211_channel_switch`:

struct ieee80211_channel_switch
===============================

.. c:type:: struct ieee80211_channel_switch

    holds the channel switch data

.. _`ieee80211_channel_switch.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_channel_switch {
        u64 timestamp;
        u32 device_timestamp;
        bool block_tx;
        struct cfg80211_chan_def chandef;
        u8 count;
    }

.. _`ieee80211_channel_switch.members`:

Members
-------

timestamp
    value in microseconds of the 64-bit Time Synchronization
    Function (TSF) timer when the frame containing the channel switch
    announcement was received. This is simply the rx.mactime parameter
    the driver passed into mac80211.

device_timestamp
    arbitrary timestamp for the device, this is the
    rx.device_timestamp parameter the driver passed to mac80211.

block_tx
    Indicates whether transmission must be blocked before the
    scheduled channel switch, as indicated by the AP.

chandef
    the new channel to switch to

count
    the number of TBTT's until the channel switch event

.. _`ieee80211_channel_switch.description`:

Description
-----------

The information provided in this structure is required for channel switch
operation.

.. _`ieee80211_vif_flags`:

enum ieee80211_vif_flags
========================

.. c:type:: enum ieee80211_vif_flags

    virtual interface flags

.. _`ieee80211_vif_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_vif_flags {
        IEEE80211_VIF_BEACON_FILTER,
        IEEE80211_VIF_SUPPORTS_CQM_RSSI,
        IEEE80211_VIF_SUPPORTS_UAPSD,
        IEEE80211_VIF_GET_NOA_UPDATE
    };

.. _`ieee80211_vif_flags.constants`:

Constants
---------

IEEE80211_VIF_BEACON_FILTER
    the device performs beacon filtering
    on this virtual interface to avoid unnecessary CPU wakeups

IEEE80211_VIF_SUPPORTS_CQM_RSSI
    the device can do connection quality
    monitoring on this virtual interface -- i.e. it can monitor
    connection quality related parameters, such as the RSSI level and
    provide notifications if configured trigger levels are reached.

IEEE80211_VIF_SUPPORTS_UAPSD
    The device can do U-APSD for this
    interface. This flag should be set during interface addition,
    but may be set/cleared as late as authentication to an AP. It is
    only valid for managed/station mode interfaces.

IEEE80211_VIF_GET_NOA_UPDATE
    request to handle NOA attributes
    and send P2P_PS notification to the driver if NOA changed, even
    this is not pure P2P vif.

.. _`ieee80211_vif`:

struct ieee80211_vif
====================

.. c:type:: struct ieee80211_vif

    per-interface data

.. _`ieee80211_vif.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_vif {
        enum nl80211_iftype type;
        struct ieee80211_bss_conf bss_conf;
        u8 addr[ETH_ALEN];
        bool p2p;
        bool csa_active;
        bool mu_mimo_owner;
        u8 cab_queue;
        u8 hw_queue[IEEE80211_NUM_ACS];
        struct ieee80211_txq *txq;
        struct ieee80211_chanctx_conf __rcu *chanctx_conf;
        u32 driver_flags;
        #ifdef CONFIG_MAC80211_DEBUGFS
        struct dentry *debugfs_dir;
        #endif
        unsigned int probe_req_reg;
        u8 drv_priv[0];
    }

.. _`ieee80211_vif.members`:

Members
-------

type
    type of this virtual interface

bss_conf
    BSS configuration for this interface, either our own
    or the BSS we're associated to

addr
    address of this interface

p2p
    indicates whether this AP or STA interface is a p2p
    interface, i.e. a GO or p2p-sta respectively

csa_active
    marks whether a channel switch is going on. Internally it is
    write-protected by sdata_lock and local->mtx so holding either is fine
    for read access.

mu_mimo_owner
    indicates interface owns MU-MIMO capability

cab_queue
    content-after-beacon (DTIM beacon really) queue, AP mode only

hw_queue
    hardware queue for each AC

txq
    the multicast data TX queue (if driver uses the TXQ abstraction)

chanctx_conf
    The channel context this interface is assigned to, or \ ``NULL``\ 
    when it is not assigned. This pointer is RCU-protected due to the TX
    path needing to access it; even though the netdev carrier will always
    be off when it is \ ``NULL``\  there can still be races and packets could be
    processed after it switches back to \ ``NULL``\ .

driver_flags
    flags/capabilities the driver has for this interface,
    these need to be set (or cleared) when the interface is added
    or, if supported by the driver, the interface type is changed
    at runtime, mac80211 will never touch this field

debugfs_dir
    debugfs dentry, can be used by drivers to create own per
    interface debug files. Note that it will be NULL for the virtual
    monitor interface (if that is requested.)

probe_req_reg
    probe requests should be reported to mac80211 for this
    interface.

drv_priv
    data area for driver use, will always be aligned to
    sizeof(void \*).

.. _`ieee80211_vif.description`:

Description
-----------

Data in this structure is continually present for driver
use during the life of a virtual interface.

.. _`wdev_to_ieee80211_vif`:

wdev_to_ieee80211_vif
=====================

.. c:function:: struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev)

    return a vif struct from a wdev

    :param struct wireless_dev \*wdev:
        the wdev to get the vif for

.. _`wdev_to_ieee80211_vif.description`:

Description
-----------

This can be used by mac80211 drivers with direct cfg80211 APIs
(like the vendor commands) that get a wdev.

Note that this function may return \ ``NULL``\  if the given wdev isn't
associated with a vif that the driver knows about (e.g. monitor
or AP_VLAN interfaces.)

.. _`ieee80211_vif_to_wdev`:

ieee80211_vif_to_wdev
=====================

.. c:function:: struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif)

    return a wdev struct from a vif

    :param struct ieee80211_vif \*vif:
        the vif to get the wdev for

.. _`ieee80211_vif_to_wdev.description`:

Description
-----------

This can be used by mac80211 drivers with direct cfg80211 APIs
(like the vendor commands) that needs to get the wdev for a vif.

Note that this function may return \ ``NULL``\  if the given wdev isn't
associated with a vif that the driver knows about (e.g. monitor
or AP_VLAN interfaces.)

.. _`ieee80211_key_flags`:

enum ieee80211_key_flags
========================

.. c:type:: enum ieee80211_key_flags

    key flags

.. _`ieee80211_key_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_key_flags {
        IEEE80211_KEY_FLAG_GENERATE_IV_MGMT,
        IEEE80211_KEY_FLAG_GENERATE_IV,
        IEEE80211_KEY_FLAG_GENERATE_MMIC,
        IEEE80211_KEY_FLAG_PAIRWISE,
        IEEE80211_KEY_FLAG_SW_MGMT_TX,
        IEEE80211_KEY_FLAG_PUT_IV_SPACE,
        IEEE80211_KEY_FLAG_RX_MGMT,
        IEEE80211_KEY_FLAG_RESERVE_TAILROOM
    };

.. _`ieee80211_key_flags.constants`:

Constants
---------

IEEE80211_KEY_FLAG_GENERATE_IV_MGMT
    This flag should be set by the
    driver for a CCMP/GCMP key to indicate that is requires IV generation
    only for managment frames (MFP).

IEEE80211_KEY_FLAG_GENERATE_IV
    This flag should be set by the
    driver to indicate that it requires IV generation for this
    particular key. Setting this flag does not necessarily mean that SKBs
    will have sufficient tailroom for ICV or MIC.

IEEE80211_KEY_FLAG_GENERATE_MMIC
    This flag should be set by
    the driver for a TKIP key if it requires Michael MIC
    generation in software.

IEEE80211_KEY_FLAG_PAIRWISE
    Set by mac80211, this flag indicates
    that the key is pairwise rather then a shared key.

IEEE80211_KEY_FLAG_SW_MGMT_TX
    This flag should be set by the driver for a
    CCMP/GCMP key if it requires CCMP/GCMP encryption of management frames
    (MFP) to be done in software.

IEEE80211_KEY_FLAG_PUT_IV_SPACE
    This flag should be set by the driver
    if space should be prepared for the IV, but the IV
    itself should not be generated. Do not set together with
    \ ``IEEE80211_KEY_FLAG_GENERATE_IV``\  on the same key. Setting this flag does
    not necessarily mean that SKBs will have sufficient tailroom for ICV or
    MIC.

IEEE80211_KEY_FLAG_RX_MGMT
    This key will be used to decrypt received
    management frames. The flag can help drivers that have a hardware
    crypto implementation that doesn't deal with management frames
    properly by allowing them to not upload the keys to hardware and
    fall back to software crypto. Note that this flag deals only with
    RX, if your crypto engine can't deal with TX you can also set the
    \ ``IEEE80211_KEY_FLAG_SW_MGMT_TX``\  flag to encrypt such frames in SW.

IEEE80211_KEY_FLAG_RESERVE_TAILROOM
    This flag should be set by the
    driver for a key to indicate that sufficient tailroom must always
    be reserved for ICV or MIC, even when HW encryption is enabled.

.. _`ieee80211_key_flags.description`:

Description
-----------

These flags are used for communication about keys between the driver
and mac80211, with the \ ``flags``\  parameter of \ :c:type:`struct ieee80211_key_conf <ieee80211_key_conf>`\ .

.. _`ieee80211_key_conf`:

struct ieee80211_key_conf
=========================

.. c:type:: struct ieee80211_key_conf

    key information

.. _`ieee80211_key_conf.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_key_conf {
        atomic64_t tx_pn;
        u32 cipher;
        u8 icv_len;
        u8 iv_len;
        u8 hw_key_idx;
        u8 flags;
        s8 keyidx;
        u8 keylen;
        u8 key[0];
    }

.. _`ieee80211_key_conf.members`:

Members
-------

tx_pn
    PN used for TX keys, may be used by the driver as well if it
    needs to do software PN assignment by itself (e.g. due to TSO)

cipher
    The key's cipher suite selector.

icv_len
    The ICV length for this key type

iv_len
    The IV length for this key type

hw_key_idx
    To be set by the driver, this is the key index the driver
    wants to be given when a frame is transmitted and needs to be
    encrypted in hardware.

flags
    key flags, see \ :c:type:`enum ieee80211_key_flags <ieee80211_key_flags>`\ .

keyidx
    the key index (0-3)

keylen
    key material length

key
    key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)

.. _`ieee80211_key_conf.description`:

Description
-----------

This key information is given by mac80211 to the driver by
the \ :c:func:`set_key`\  callback in \ :c:type:`struct ieee80211_ops <ieee80211_ops>`\ .

.. _`ieee80211_key_conf.data-block`:

data block
----------

- Temporal Encryption Key (128 bits)
- Temporal Authenticator Tx MIC Key (64 bits)
- Temporal Authenticator Rx MIC Key (64 bits)

.. _`ieee80211_key_seq`:

struct ieee80211_key_seq
========================

.. c:type:: struct ieee80211_key_seq

    key sequence counter

.. _`ieee80211_key_seq.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_key_seq {
        union {unnamed_union};
    }

.. _`ieee80211_key_seq.members`:

Members
-------

{unnamed_union}
    anonymous


.. _`ieee80211_cipher_scheme`:

struct ieee80211_cipher_scheme
==============================

.. c:type:: struct ieee80211_cipher_scheme

    cipher scheme

.. _`ieee80211_cipher_scheme.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_cipher_scheme {
        u32 cipher;
        u16 iftype;
        u8 hdr_len;
        u8 pn_len;
        u8 pn_off;
        u8 key_idx_off;
        u8 key_idx_mask;
        u8 key_idx_shift;
        u8 mic_len;
    }

.. _`ieee80211_cipher_scheme.members`:

Members
-------

cipher
    a cipher suite selector

iftype
    a cipher iftype bit mask indicating an allowed cipher usage

hdr_len
    a length of a security header used the cipher

pn_len
    a length of a packet number in the security header

pn_off
    an offset of pn from the beginning of the security header

key_idx_off
    an offset of key index byte in the security header

key_idx_mask
    a bit mask of key_idx bits

key_idx_shift
    a bit shift needed to get key_idx

mic_len
    a mic length in bytes

.. _`ieee80211_cipher_scheme.description`:

Description
-----------

This structure contains a cipher scheme information defining
the secure packet crypto handling.

.. _`ieee80211_cipher_scheme.key_idx-value-calculation`:

key_idx value calculation
-------------------------

(sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift

.. _`set_key_cmd`:

enum set_key_cmd
================

.. c:type:: enum set_key_cmd

    key command

.. _`set_key_cmd.definition`:

Definition
----------

.. code-block:: c

    enum set_key_cmd {
        SET_KEY,
        DISABLE_KEY
    };

.. _`set_key_cmd.constants`:

Constants
---------

SET_KEY
    a key is set

DISABLE_KEY
    a key must be disabled

.. _`set_key_cmd.description`:

Description
-----------

Used with the \ :c:func:`set_key`\  callback in \ :c:type:`struct ieee80211_ops <ieee80211_ops>`\ , this
indicates whether a key is being removed or added.

.. _`ieee80211_sta_state`:

enum ieee80211_sta_state
========================

.. c:type:: enum ieee80211_sta_state

    station state

.. _`ieee80211_sta_state.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_sta_state {
        IEEE80211_STA_NOTEXIST,
        IEEE80211_STA_NONE,
        IEEE80211_STA_AUTH,
        IEEE80211_STA_ASSOC,
        IEEE80211_STA_AUTHORIZED
    };

.. _`ieee80211_sta_state.constants`:

Constants
---------

IEEE80211_STA_NOTEXIST
    station doesn't exist at all,
    this is a special state for add/remove transitions

IEEE80211_STA_NONE
    station exists without special state

IEEE80211_STA_AUTH
    station is authenticated

IEEE80211_STA_ASSOC
    station is associated

IEEE80211_STA_AUTHORIZED
    station is authorized (802.1X)

.. _`ieee80211_sta_rx_bandwidth`:

enum ieee80211_sta_rx_bandwidth
===============================

.. c:type:: enum ieee80211_sta_rx_bandwidth

    station RX bandwidth

.. _`ieee80211_sta_rx_bandwidth.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_sta_rx_bandwidth {
        IEEE80211_STA_RX_BW_20,
        IEEE80211_STA_RX_BW_40,
        IEEE80211_STA_RX_BW_80,
        IEEE80211_STA_RX_BW_160
    };

.. _`ieee80211_sta_rx_bandwidth.constants`:

Constants
---------

IEEE80211_STA_RX_BW_20
    station can only receive 20 MHz

IEEE80211_STA_RX_BW_40
    station can receive up to 40 MHz

IEEE80211_STA_RX_BW_80
    station can receive up to 80 MHz

IEEE80211_STA_RX_BW_160
    station can receive up to 160 MHz
    (including 80+80 MHz)

.. _`ieee80211_sta_rx_bandwidth.implementation-note`:

Implementation note
-------------------

20 must be zero to be initialized
correctly, the values must be sorted.

.. _`ieee80211_sta_rates`:

struct ieee80211_sta_rates
==========================

.. c:type:: struct ieee80211_sta_rates

    station rate selection table

.. _`ieee80211_sta_rates.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_sta_rates {
        struct rcu_head rcu_head;
        struct rate[IEEE80211_TX_RATE_TABLE_SIZE];
    }

.. _`ieee80211_sta_rates.members`:

Members
-------

rcu_head
    RCU head used for freeing the table on update

rate
    transmit rates/flags to be used by default.
    Overriding entries per-packet is possible by using cb tx control.

.. _`ieee80211_sta`:

struct ieee80211_sta
====================

.. c:type:: struct ieee80211_sta

    station table entry

.. _`ieee80211_sta.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_sta {
        u32 supp_rates[NUM_NL80211_BANDS];
        u8 addr[ETH_ALEN];
        u16 aid;
        struct ieee80211_sta_ht_cap ht_cap;
        struct ieee80211_sta_vht_cap vht_cap;
        bool wme;
        u8 uapsd_queues;
        u8 max_sp;
        u8 rx_nss;
        enum ieee80211_sta_rx_bandwidth bandwidth;
        enum ieee80211_smps_mode smps_mode;
        struct ieee80211_sta_rates __rcu *rates;
        bool tdls;
        bool tdls_initiator;
        bool mfp;
        u8 max_amsdu_subframes;
        u16 max_amsdu_len;
        bool support_p2p_ps;
        u16 max_rc_amsdu_len;
        struct ieee80211_txq  *txq[IEEE80211_NUM_TIDS];
        u8 drv_priv[0];
    }

.. _`ieee80211_sta.members`:

Members
-------

supp_rates
    Bitmap of supported rates (per band)

addr
    MAC address

aid
    AID we assigned to the station if we're an AP

ht_cap
    HT capabilities of this STA; restricted to our own capabilities

vht_cap
    VHT capabilities of this STA; restricted to our own capabilities

wme
    indicates whether the STA supports QoS/WME (if local devices does,
    otherwise always false)

uapsd_queues
    bitmap of queues configured for uapsd. Only valid
    if wme is supported.

max_sp
    max Service Period. Only valid if wme is supported.

rx_nss
    in HT/VHT, the maximum number of spatial streams the
    station can receive at the moment, changed by operating mode
    notifications and capabilities. The value is only valid after
    the station moves to associated state.

bandwidth
    current bandwidth the station can receive with

smps_mode
    current SMPS mode (off, static or dynamic)

rates
    rate control selection table

tdls
    indicates whether the STA is a TDLS peer

tdls_initiator
    indicates the STA is an initiator of the TDLS link. Only
    valid if the STA is a TDLS peer in the first place.

mfp
    indicates whether the STA uses management frame protection or not.

max_amsdu_subframes
    indicates the maximal number of MSDUs in a single
    A-MSDU. Taken from the Extended Capabilities element. 0 means
    unlimited.

max_amsdu_len
    indicates the maximal length of an A-MSDU in bytes. This
    field is always valid for packets with a VHT preamble. For packets
    with a HT preamble, additional limits apply:
    + If the skb is transmitted as part of a BA agreement, the
    A-MSDU maximal size is min(max_amsdu_len, 4065) bytes.
    + If the skb is not part of a BA aggreement, the A-MSDU maximal
    size is min(max_amsdu_len, 7935) bytes.
    Both additional HT limits must be enforced by the low level driver.
    This is defined by the spec (IEEE 802.11-2012 section 8.3.2.2 NOTE 2).

support_p2p_ps
    indicates whether the STA supports P2P PS mechanism or not.

max_rc_amsdu_len
    Maximum A-MSDU size in bytes recommended by rate control.

txq
    per-TID data TX queues (if driver uses the TXQ abstraction)

drv_priv
    data area for driver use, will always be aligned to
    sizeof(void \*), size is determined in hw information.

.. _`ieee80211_sta.description`:

Description
-----------

A station table entry represents a station we are possibly
communicating with. Since stations are RCU-managed in
mac80211, any ieee80211_sta pointer you get access to must
either be protected by \ :c:func:`rcu_read_lock`\  explicitly or implicitly,
or you must take good care to not use such a pointer after a
call to your sta_remove callback that removed it.

.. _`sta_notify_cmd`:

enum sta_notify_cmd
===================

.. c:type:: enum sta_notify_cmd

    sta notify command

.. _`sta_notify_cmd.definition`:

Definition
----------

.. code-block:: c

    enum sta_notify_cmd {
        STA_NOTIFY_SLEEP,
        STA_NOTIFY_AWAKE
    };

.. _`sta_notify_cmd.constants`:

Constants
---------

STA_NOTIFY_SLEEP
    a station is now sleeping

STA_NOTIFY_AWAKE
    a sleeping station woke up

.. _`sta_notify_cmd.description`:

Description
-----------

Used with the \ :c:func:`sta_notify`\  callback in \ :c:type:`struct ieee80211_ops <ieee80211_ops>`\ , this
indicates if an associated station made a power state transition.

.. _`ieee80211_tx_control`:

struct ieee80211_tx_control
===========================

.. c:type:: struct ieee80211_tx_control

    TX control data

.. _`ieee80211_tx_control.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tx_control {
        struct ieee80211_sta *sta;
    }

.. _`ieee80211_tx_control.members`:

Members
-------

sta
    station table entry, this sta pointer may be NULL and
    it is not allowed to copy the pointer, due to RCU.

.. _`ieee80211_txq`:

struct ieee80211_txq
====================

.. c:type:: struct ieee80211_txq

    Software intermediate tx queue

.. _`ieee80211_txq.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_txq {
        struct ieee80211_vif *vif;
        struct ieee80211_sta *sta;
        u8 tid;
        u8 ac;
        u8 drv_priv[0];
    }

.. _`ieee80211_txq.members`:

Members
-------

vif
    \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

sta
    station table entry, \ ``NULL``\  for per-vif queue

tid
    the TID for this queue (unused for per-vif queue)

ac
    the AC for this queue

drv_priv
    driver private area, sized by hw->txq_data_size

.. _`ieee80211_txq.description`:

Description
-----------

The driver can obtain packets from this queue by calling
\ :c:func:`ieee80211_tx_dequeue`\ .

.. _`ieee80211_hw_flags`:

enum ieee80211_hw_flags
=======================

.. c:type:: enum ieee80211_hw_flags

    hardware flags

.. _`ieee80211_hw_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_hw_flags {
        IEEE80211_HW_HAS_RATE_CONTROL,
        IEEE80211_HW_RX_INCLUDES_FCS,
        IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,
        IEEE80211_HW_SIGNAL_UNSPEC,
        IEEE80211_HW_SIGNAL_DBM,
        IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,
        IEEE80211_HW_SPECTRUM_MGMT,
        IEEE80211_HW_AMPDU_AGGREGATION,
        IEEE80211_HW_SUPPORTS_PS,
        IEEE80211_HW_PS_NULLFUNC_STACK,
        IEEE80211_HW_SUPPORTS_DYNAMIC_PS,
        IEEE80211_HW_MFP_CAPABLE,
        IEEE80211_HW_WANT_MONITOR_VIF,
        IEEE80211_HW_NO_AUTO_VIF,
        IEEE80211_HW_SW_CRYPTO_CONTROL,
        IEEE80211_HW_SUPPORT_FAST_XMIT,
        IEEE80211_HW_REPORTS_TX_ACK_STATUS,
        IEEE80211_HW_CONNECTION_MONITOR,
        IEEE80211_HW_QUEUE_CONTROL,
        IEEE80211_HW_SUPPORTS_PER_STA_GTK,
        IEEE80211_HW_AP_LINK_PS,
        IEEE80211_HW_TX_AMPDU_SETUP_IN_HW,
        IEEE80211_HW_SUPPORTS_RC_TABLE,
        IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,
        IEEE80211_HW_TIMING_BEACON_ONLY,
        IEEE80211_HW_SUPPORTS_HT_CCK_RATES,
        IEEE80211_HW_CHANCTX_STA_CSA,
        IEEE80211_HW_SUPPORTS_CLONED_SKBS,
        IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,
        IEEE80211_HW_TDLS_WIDER_BW,
        IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,
        IEEE80211_HW_BEACON_TX_STATUS,
        IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,
        IEEE80211_HW_SUPPORTS_REORDERING_BUFFER,
        IEEE80211_HW_USES_RSS,
        IEEE80211_HW_TX_AMSDU,
        IEEE80211_HW_TX_FRAG_LIST,
        NUM_IEEE80211_HW_FLAGS
    };

.. _`ieee80211_hw_flags.constants`:

Constants
---------

IEEE80211_HW_HAS_RATE_CONTROL
    The hardware or firmware includes rate control, and cannot be
    controlled by the stack. As such, no rate control algorithm
    should be instantiated, and the TX rate reported to userspace
    will be taken from the TX status instead of the rate control
    algorithm.
    Note that this requires that the driver implement a number of
    callbacks so it has the correct information, it needs to have
    the \ ``set_rts_threshold``\  callback and must look at the BSS config
    \ ``use_cts_prot``\  for G/N protection, \ ``use_short_slot``\  for slot
    timing in 2.4 GHz and \ ``use_short_preamble``\  for preambles for
    CCK frames.

IEEE80211_HW_RX_INCLUDES_FCS
    Indicates that received frames passed to the stack include
    the FCS at the end.

IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING
    Some wireless LAN chipsets buffer broadcast/multicast frames
    for power saving stations in the hardware/firmware and others
    rely on the host system for such buffering. This option is used
    to configure the IEEE 802.11 upper layer to buffer broadcast and
    multicast frames when there are power saving stations so that
    the driver can fetch them with \ :c:func:`ieee80211_get_buffered_bc`\ .

IEEE80211_HW_SIGNAL_UNSPEC
    Hardware can provide signal values but we don't know its units. We
    expect values between 0 and \ ``max_signal``\ .
    If possible please provide dB or dBm instead.

IEEE80211_HW_SIGNAL_DBM
    Hardware gives signal values in dBm, decibel difference from
    one milliwatt. This is the preferred method since it is standardized
    between different devices. \ ``max_signal``\  does not need to be set.

IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC
    This device needs to get data from beacon before association (i.e.
    dtim_period).

IEEE80211_HW_SPECTRUM_MGMT
    Hardware supports spectrum management defined in 802.11h
    Measurement, Channel Switch, Quieting, TPC

IEEE80211_HW_AMPDU_AGGREGATION
    Hardware supports 11n A-MPDU aggregation.

IEEE80211_HW_SUPPORTS_PS
    Hardware has power save support (i.e. can go to sleep).

IEEE80211_HW_PS_NULLFUNC_STACK
    Hardware requires nullfunc frame handling in stack, implies
    stack support for dynamic PS.

IEEE80211_HW_SUPPORTS_DYNAMIC_PS
    Hardware has support for dynamic PS.

IEEE80211_HW_MFP_CAPABLE
    Hardware supports management frame protection (MFP, IEEE 802.11w).

IEEE80211_HW_WANT_MONITOR_VIF
    The driver would like to be informed of
    a virtual monitor interface when monitor interfaces are the only
    active interfaces.

IEEE80211_HW_NO_AUTO_VIF
    The driver would like for no wlanX to
    be created.  It is expected user-space will create vifs as
    desired (and thus have them named as desired).

IEEE80211_HW_SW_CRYPTO_CONTROL
    The driver wants to control which of the
    crypto algorithms can be done in software - so don't automatically
    try to fall back to it if hardware crypto fails, but do so only if
    the driver returns 1. This also forces the driver to advertise its
    supported cipher suites.

IEEE80211_HW_SUPPORT_FAST_XMIT
    The driver/hardware supports fast-xmit,
    this currently requires only the ability to calculate the duration
    for frames.

IEEE80211_HW_REPORTS_TX_ACK_STATUS
    Hardware can provide ack status reports of Tx frames to
    the stack.

IEEE80211_HW_CONNECTION_MONITOR
    The hardware performs its own connection monitoring, including
    periodic keep-alives to the AP and probing the AP on beacon loss.

IEEE80211_HW_QUEUE_CONTROL
    The driver wants to control per-interface
    queue mapping in order to use different queues (not just one per AC)
    for different virtual interfaces. See the doc section on HW queue
    control for more details.

IEEE80211_HW_SUPPORTS_PER_STA_GTK
    The device's crypto engine supports
    per-station GTKs as used by IBSS RSN or during fast transition. If
    the device doesn't support per-station GTKs, but can be asked not
    to decrypt group addressed frames, then IBSS RSN support is still
    possible but software crypto will be used. Advertise the wiphy flag
    only in that case.

IEEE80211_HW_AP_LINK_PS
    When operating in AP mode the device
    autonomously manages the PS status of connected stations. When
    this flag is set mac80211 will not trigger PS mode for connected
    stations based on the PM bit of incoming frames.
    Use \ :c:func:`ieee80211_start_ps`\ /\ :c:func:`ieee8021_end_ps`\  to manually configure
    the PS mode of connected stations.

IEEE80211_HW_TX_AMPDU_SETUP_IN_HW
    The device handles TX A-MPDU session
    setup strictly in HW. mac80211 should not attempt to do this in
    software.

IEEE80211_HW_SUPPORTS_RC_TABLE
    The driver supports using a rate
    selection table provided by the rate control algorithm.

IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF
    Use the P2P Device address for any
    P2P Interface. This will be honoured even if more than one interface
    is supported.

IEEE80211_HW_TIMING_BEACON_ONLY
    Use sync timing from beacon frames
    only, to allow getting TBTT of a DTIM beacon.

IEEE80211_HW_SUPPORTS_HT_CCK_RATES
    Hardware supports mixing HT/CCK rates
    and can cope with CCK rates in an aggregation session (e.g. by not
    using aggregation for such frames.)

IEEE80211_HW_CHANCTX_STA_CSA
    Support 802.11h based channel-switch (CSA)
    for a single active channel while using channel contexts. When support
    is not enabled the default action is to disconnect when getting the
    CSA frame.

IEEE80211_HW_SUPPORTS_CLONED_SKBS
    The driver will never modify the payload
    or tailroom of TX skbs without copying them first.

IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS
    The HW supports scanning on all bands
    in one command, mac80211 doesn't have to run separate scans per band.

IEEE80211_HW_TDLS_WIDER_BW
    The device/driver supports wider bandwidth
    than then BSS bandwidth for a TDLS link on the base channel.

IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU
    The driver supports receiving A-MSDUs
    within A-MPDU.

IEEE80211_HW_BEACON_TX_STATUS
    The device/driver provides TX status
    for sent beacons.

IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR
    Hardware (or driver) requires that each
    station has a unique address, i.e. each station entry can be identified
    by just its MAC address; this prevents, for example, the same station
    from connecting to two virtual AP interfaces at the same time.

IEEE80211_HW_SUPPORTS_REORDERING_BUFFER
    Hardware (or driver) manages the
    reordering buffer internally, guaranteeing mac80211 receives frames in
    order and does not need to manage its own reorder buffer or BA session
    timeout.

IEEE80211_HW_USES_RSS
    The device uses RSS and thus requires parallel RX,
    which implies using per-CPU station statistics.

IEEE80211_HW_TX_AMSDU
    Hardware (or driver) supports software aggregated
    A-MSDU frames. Requires software tx queueing and fast-xmit support.
    When not using minstrel/minstrel_ht rate control, the driver must
    limit the maximum A-MSDU size based on the current tx rate by setting
    max_rc_amsdu_len in struct ieee80211_sta.

IEEE80211_HW_TX_FRAG_LIST
    Hardware (or driver) supports sending frag_list
    skbs, needed for zero-copy software A-MSDU.

NUM_IEEE80211_HW_FLAGS
    number of hardware flags, used for sizing arrays

.. _`ieee80211_hw_flags.description`:

Description
-----------

These flags are used to indicate hardware capabilities to
the stack. Generally, flags here should have their meaning
done in a way that the simplest hardware doesn't need setting
any particular flags. There are some exceptions to this rule,
however, so you are advised to review these flags carefully.

.. _`ieee80211_hw`:

struct ieee80211_hw
===================

.. c:type:: struct ieee80211_hw

    hardware information and state

.. _`ieee80211_hw.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_hw {
        struct ieee80211_conf conf;
        struct wiphy *wiphy;
        const char *rate_control_algorithm;
        void *priv;
        unsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];
        unsigned int extra_tx_headroom;
        unsigned int extra_beacon_tailroom;
        int vif_data_size;
        int sta_data_size;
        int chanctx_data_size;
        int txq_data_size;
        u16 queues;
        u16 max_listen_interval;
        s8 max_signal;
        u8 max_rates;
        u8 max_report_rates;
        u8 max_rate_tries;
        u8 max_rx_aggregation_subframes;
        u8 max_tx_aggregation_subframes;
        u8 max_tx_fragments;
        u8 offchannel_tx_hw_queue;
        u8 radiotap_mcs_details;
        u16 radiotap_vht_details;
        netdev_features_t netdev_features;
        u8 uapsd_queues;
        u8 uapsd_max_sp_len;
        u8 n_cipher_schemes;
        const struct ieee80211_cipher_scheme *cipher_schemes;
        int txq_ac_max_pending;
    }

.. _`ieee80211_hw.members`:

Members
-------

conf
    \ :c:type:`struct ieee80211_conf <ieee80211_conf>`\ , device configuration, don't use.

wiphy
    This points to the \ :c:type:`struct wiphy <wiphy>`\  allocated for this
    802.11 PHY. You must fill in the \ ``perm_addr``\  and \ ``dev``\ 
    members of this structure using \ :c:func:`SET_IEEE80211_DEV`\ 
    and \ :c:func:`SET_IEEE80211_PERM_ADDR`\ . Additionally, all supported
    bands (with channels, bitrates) are registered here.

rate_control_algorithm
    rate control algorithm for this hardware.
    If unset (NULL), the default algorithm will be used. Must be
    set before calling \ :c:func:`ieee80211_register_hw`\ .

priv
    pointer to private area that was allocated for driver use
    along with this structure.

flags
    hardware flags, see \ :c:type:`enum ieee80211_hw_flags <ieee80211_hw_flags>`\ .

extra_tx_headroom
    headroom to reserve in each transmit skb
    for use by the driver (e.g. for transmit headers.)

extra_beacon_tailroom
    tailroom to reserve in each beacon tx skb.
    Can be used by drivers to add extra IEs.

vif_data_size
    size (in bytes) of the drv_priv data area
    within \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\ .

sta_data_size
    size (in bytes) of the drv_priv data area
    within \ :c:type:`struct ieee80211_sta <ieee80211_sta>`\ .

chanctx_data_size
    size (in bytes) of the drv_priv data area
    within \ :c:type:`struct ieee80211_chanctx_conf <ieee80211_chanctx_conf>`\ .

txq_data_size
    size (in bytes) of the drv_priv data area
    within \ ``struct``\  ieee80211_txq.

queues
    number of available hardware transmit queues for
    data packets. WMM/QoS requires at least four, these
    queues need to have configurable access parameters.

max_listen_interval
    max listen interval in units of beacon interval
    that HW supports

max_signal
    Maximum value for signal (rssi) in RX information, used
    only when \ ``IEEE80211_HW_SIGNAL_UNSPEC``\  or \ ``IEEE80211_HW_SIGNAL_DB``\ 

max_rates
    maximum number of alternate rate retry stages the hw
    can handle.

max_report_rates
    maximum number of alternate rate retry stages
    the hw can report back.

max_rate_tries
    maximum number of tries for each stage

max_rx_aggregation_subframes
    maximum buffer size (number of
    sub-frames) to be used for A-MPDU block ack receiver
    aggregation.
    This is only relevant if the device has restrictions on the
    number of subframes, if it relies on mac80211 to do reordering
    it shouldn't be set.

max_tx_aggregation_subframes
    maximum number of subframes in an
    aggregate an HT driver will transmit. Though ADDBA will advertise
    a constant value of 64 as some older APs can crash if the window
    size is smaller (an example is LinkSys WRT120N with FW v1.0.07
    build 002 Jun 18 2012).

max_tx_fragments
    maximum number of tx buffers per (A)-MSDU, sum
    of 1 + skb_shinfo(skb)->nr_frags for each skb in the frag_list.

offchannel_tx_hw_queue
    HW queue ID to use for offchannel TX
    (if \ ``IEEE80211_HW_QUEUE_CONTROL``\  is set)

radiotap_mcs_details
    lists which MCS information can the HW
    reports, by default it is set to \_MCS, \_GI and \_BW but doesn't
    include \_FMT. Use \ ``IEEE80211_RADIOTAP_MCS_HAVE``\ \_\* values, only
    adding \_BW is supported today.

radiotap_vht_details
    lists which VHT MCS information the HW reports,
    the default is \_GI \| \_BANDWIDTH.
    Use the \ ``IEEE80211_RADIOTAP_VHT_KNOWN``\ \_\* values.

netdev_features
    netdev features to be set in each netdev created
    from this HW. Note that not all features are usable with mac80211,
    other features will be rejected during HW registration.

uapsd_queues
    This bitmap is included in (re)association frame to indicate
    for each access category if it is uAPSD trigger-enabled and delivery-
    enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC\_\* to set this bitmap.
    Each bit corresponds to different AC. Value '1' in specific bit means
    that corresponding AC is both trigger- and delivery-enabled. '0' means
    neither enabled.

uapsd_max_sp_len
    maximum number of total buffered frames the WMM AP may
    deliver to a WMM STA during any Service Period triggered by the WMM STA.
    Use IEEE80211_WMM_IE_STA_QOSINFO_SP\_\* for correct values.

n_cipher_schemes
    a size of an array of cipher schemes definitions.

cipher_schemes
    a pointer to an array of cipher scheme definitions
    supported by HW.

txq_ac_max_pending
    maximum number of frames per AC pending in all txq
    entries for a vif.

.. _`ieee80211_hw.description`:

Description
-----------

This structure contains the configuration and hardware
information for an 802.11 PHY.

.. _`ieee80211_scan_request`:

struct ieee80211_scan_request
=============================

.. c:type:: struct ieee80211_scan_request

    hw scan request

.. _`ieee80211_scan_request.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_scan_request {
        struct ieee80211_scan_ies ies;
        struct cfg80211_scan_request req;
    }

.. _`ieee80211_scan_request.members`:

Members
-------

ies
    pointers different parts of IEs (in req.ie)

req
    cfg80211 request.

.. _`ieee80211_tdls_ch_sw_params`:

struct ieee80211_tdls_ch_sw_params
==================================

.. c:type:: struct ieee80211_tdls_ch_sw_params

    TDLS channel switch parameters

.. _`ieee80211_tdls_ch_sw_params.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tdls_ch_sw_params {
        struct ieee80211_sta *sta;
        struct cfg80211_chan_def *chandef;
        u8 action_code;
        u32 status;
        u32 timestamp;
        u16 switch_time;
        u16 switch_timeout;
        struct sk_buff *tmpl_skb;
        u32 ch_sw_tm_ie;
    }

.. _`ieee80211_tdls_ch_sw_params.members`:

Members
-------

sta
    peer this TDLS channel-switch request/response came from

chandef
    channel referenced in a TDLS channel-switch request

action_code
    see \ :c:type:`enum ieee80211_tdls_actioncode <ieee80211_tdls_actioncode>`\ 

status
    channel-switch response status

timestamp
    time at which the frame was received

switch_time
    switch-timing parameter received in the frame

switch_timeout
    switch-timing parameter received in the frame

tmpl_skb
    TDLS switch-channel response template

ch_sw_tm_ie
    offset of the channel-switch timing IE inside \ ``tmpl_skb``\ 

.. _`wiphy_to_ieee80211_hw`:

wiphy_to_ieee80211_hw
=====================

.. c:function:: struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy)

    return a mac80211 driver hw struct from a wiphy

    :param struct wiphy \*wiphy:
        the \ :c:type:`struct wiphy <wiphy>`\  which we want to query

.. _`wiphy_to_ieee80211_hw.description`:

Description
-----------

mac80211 drivers can use this to get to their respective
\ :c:type:`struct ieee80211_hw <ieee80211_hw>`\ . Drivers wishing to get to their own private
structure can then access it via hw->priv. Note that mac802111 drivers should
not use \ :c:func:`wiphy_priv`\  to try to get their private driver structure as this
is already used internally by mac80211.

.. _`wiphy_to_ieee80211_hw.return`:

Return
------

The mac80211 driver hw struct of \ ``wiphy``\ .

.. _`set_ieee80211_dev`:

SET_IEEE80211_DEV
=================

.. c:function:: void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)

    set device for 802.11 hardware

    :param struct ieee80211_hw \*hw:
        the \ :c:type:`struct ieee80211_hw <ieee80211_hw>`\  to set the device for

    :param struct device \*dev:
        the \ :c:type:`struct device <device>`\  of this 802.11 device

.. _`set_ieee80211_perm_addr`:

SET_IEEE80211_PERM_ADDR
=======================

.. c:function:: void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)

    set the permanent MAC address for 802.11 hardware

    :param struct ieee80211_hw \*hw:
        the \ :c:type:`struct ieee80211_hw <ieee80211_hw>`\  to set the MAC address for

    :param const u8 \*addr:
        the address to set

.. _`ieee80211_free_txskb`:

ieee80211_free_txskb
====================

.. c:function:: void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)

    free TX skb

    :param struct ieee80211_hw \*hw:
        the hardware

    :param struct sk_buff \*skb:
        the skb

.. _`ieee80211_free_txskb.description`:

Description
-----------

Free a transmit skb. Use this funtion when some failure
to transmit happened and thus status cannot be reported.

.. _`ieee80211_filter_flags`:

enum ieee80211_filter_flags
===========================

.. c:type:: enum ieee80211_filter_flags

    hardware filter flags

.. _`ieee80211_filter_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_filter_flags {
        FIF_ALLMULTI,
        FIF_FCSFAIL,
        FIF_PLCPFAIL,
        FIF_BCN_PRBRESP_PROMISC,
        FIF_CONTROL,
        FIF_OTHER_BSS,
        FIF_PSPOLL,
        FIF_PROBE_REQ
    };

.. _`ieee80211_filter_flags.constants`:

Constants
---------

FIF_ALLMULTI
    pass all multicast frames, this is used if requested
    by the user or if the hardware is not capable of filtering by
    multicast address.

FIF_FCSFAIL
    pass frames with failed FCS (but you need to set the
    \ ``RX_FLAG_FAILED_FCS_CRC``\  for them)

FIF_PLCPFAIL
    pass frames with failed PLCP CRC (but you need to set
    the \ ``RX_FLAG_FAILED_PLCP_CRC``\  for them

FIF_BCN_PRBRESP_PROMISC
    This flag is set during scanning to indicate
    to the hardware that it should not filter beacons or probe responses
    by BSSID. Filtering them can greatly reduce the amount of processing
    mac80211 needs to do and the amount of CPU wakeups, so you should
    honour this flag if possible.

FIF_CONTROL
    pass control frames (except for PS Poll) addressed to this
    station

FIF_OTHER_BSS
    pass frames destined to other BSSes

FIF_PSPOLL
    pass PS Poll frames

FIF_PROBE_REQ
    pass probe request frames

.. _`ieee80211_filter_flags.description`:

Description
-----------

These flags determine what the filter in hardware should be
programmed to let through and what should not be passed to the
stack. It is always safe to pass more frames than requested,
but this has negative impact on power consumption.

.. _`ieee80211_ampdu_mlme_action`:

enum ieee80211_ampdu_mlme_action
================================

.. c:type:: enum ieee80211_ampdu_mlme_action

    A-MPDU actions

.. _`ieee80211_ampdu_mlme_action.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_ampdu_mlme_action {
        IEEE80211_AMPDU_RX_START,
        IEEE80211_AMPDU_RX_STOP,
        IEEE80211_AMPDU_TX_START,
        IEEE80211_AMPDU_TX_STOP_CONT,
        IEEE80211_AMPDU_TX_STOP_FLUSH,
        IEEE80211_AMPDU_TX_STOP_FLUSH_CONT,
        IEEE80211_AMPDU_TX_OPERATIONAL
    };

.. _`ieee80211_ampdu_mlme_action.constants`:

Constants
---------

IEEE80211_AMPDU_RX_START
    start RX aggregation

IEEE80211_AMPDU_RX_STOP
    stop RX aggregation

IEEE80211_AMPDU_TX_START
    start TX aggregation

IEEE80211_AMPDU_TX_STOP_CONT
    stop TX aggregation but continue transmitting
    queued packets, now unaggregated. After all packets are transmitted the
    driver has to call \ :c:func:`ieee80211_stop_tx_ba_cb_irqsafe`\ .

IEEE80211_AMPDU_TX_STOP_FLUSH
    stop TX aggregation and flush all packets,
    called when the station is removed. There's no need or reason to call
    \ :c:func:`ieee80211_stop_tx_ba_cb_irqsafe`\  in this case as mac80211 assumes the
    session is gone and removes the station.

IEEE80211_AMPDU_TX_STOP_FLUSH_CONT
    called when TX aggregation is stopped
    but the driver hasn't called \ :c:func:`ieee80211_stop_tx_ba_cb_irqsafe`\  yet and
    now the connection is dropped and the station will be removed. Drivers
    should clean up and drop remaining packets when this is called.

IEEE80211_AMPDU_TX_OPERATIONAL
    TX aggregation has become operational

.. _`ieee80211_ampdu_mlme_action.description`:

Description
-----------

These flags are used with the \ :c:func:`ampdu_action`\  callback in
\ :c:type:`struct ieee80211_ops <ieee80211_ops>`\  to indicate which action is needed.

Note that drivers MUST be able to deal with a TX aggregation
session being stopped even before they OK'ed starting it by
calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
might receive the addBA frame and send a delBA right away!

.. _`ieee80211_ampdu_params`:

struct ieee80211_ampdu_params
=============================

.. c:type:: struct ieee80211_ampdu_params

    AMPDU action parameters

.. _`ieee80211_ampdu_params.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_ampdu_params {
        enum ieee80211_ampdu_mlme_action action;
        struct ieee80211_sta *sta;
        u16 tid;
        u16 ssn;
        u8 buf_size;
        bool amsdu;
        u16 timeout;
    }

.. _`ieee80211_ampdu_params.members`:

Members
-------

action
    the ampdu action, value from \ ``ieee80211_ampdu_mlme_action``\ .

sta
    peer of this AMPDU session

tid
    tid of the BA session

ssn
    start sequence number of the session. TX/RX_STOP can pass 0. When
    action is set to \ ``IEEE80211_AMPDU_RX_START``\  the driver passes back the
    actual ssn value used to start the session and writes the value here.

buf_size
    reorder buffer size  (number of subframes). Valid only when the
    action is set to \ ``IEEE80211_AMPDU_RX_START``\  or
    \ ``IEEE80211_AMPDU_TX_OPERATIONAL``\ 

amsdu
    indicates the peer's ability to receive A-MSDU within A-MPDU.
    valid when the action is set to \ ``IEEE80211_AMPDU_TX_OPERATIONAL``\ 

timeout
    BA session timeout. Valid only when the action is set to
    \ ``IEEE80211_AMPDU_RX_START``\ 

.. _`ieee80211_frame_release_type`:

enum ieee80211_frame_release_type
=================================

.. c:type:: enum ieee80211_frame_release_type

    frame release reason

.. _`ieee80211_frame_release_type.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_frame_release_type {
        IEEE80211_FRAME_RELEASE_PSPOLL,
        IEEE80211_FRAME_RELEASE_UAPSD
    };

.. _`ieee80211_frame_release_type.constants`:

Constants
---------

IEEE80211_FRAME_RELEASE_PSPOLL
    frame released for PS-Poll

IEEE80211_FRAME_RELEASE_UAPSD
    frame(s) released due to
    frame received on trigger-enabled AC

.. _`ieee80211_rate_control_changed`:

enum ieee80211_rate_control_changed
===================================

.. c:type:: enum ieee80211_rate_control_changed

    flags to indicate what changed

.. _`ieee80211_rate_control_changed.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_rate_control_changed {
        IEEE80211_RC_BW_CHANGED,
        IEEE80211_RC_SMPS_CHANGED,
        IEEE80211_RC_SUPP_RATES_CHANGED,
        IEEE80211_RC_NSS_CHANGED
    };

.. _`ieee80211_rate_control_changed.constants`:

Constants
---------

IEEE80211_RC_BW_CHANGED
    The bandwidth that can be used to transmit
    to this station changed. The actual bandwidth is in the station
    information -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
    flag changes, for HT and VHT the bandwidth field changes.

IEEE80211_RC_SMPS_CHANGED
    The SMPS state of the station changed.

IEEE80211_RC_SUPP_RATES_CHANGED
    The supported rate set of this peer
    changed (in IBSS mode) due to discovering more information about
    the peer.

IEEE80211_RC_NSS_CHANGED
    N_SS (number of spatial streams) was changed
    by the peer

.. _`ieee80211_roc_type`:

enum ieee80211_roc_type
=======================

.. c:type:: enum ieee80211_roc_type

    remain on channel type

.. _`ieee80211_roc_type.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_roc_type {
        IEEE80211_ROC_TYPE_NORMAL,
        IEEE80211_ROC_TYPE_MGMT_TX
    };

.. _`ieee80211_roc_type.constants`:

Constants
---------

IEEE80211_ROC_TYPE_NORMAL
    There are no special requirements for this ROC.

IEEE80211_ROC_TYPE_MGMT_TX
    The remain on channel request is required
    for sending managment frames offchannel.

.. _`ieee80211_roc_type.description`:

Description
-----------

With the support for multi channel contexts and multi channel operations,
remain on channel operations might be limited/deferred/aborted by other
flows/operations which have higher priority (and vise versa).
Specifying the ROC type can be used by devices to prioritize the ROC
operations compared to other operations/flows.

.. _`ieee80211_reconfig_type`:

enum ieee80211_reconfig_type
============================

.. c:type:: enum ieee80211_reconfig_type

    reconfig type

.. _`ieee80211_reconfig_type.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_reconfig_type {
        IEEE80211_RECONFIG_TYPE_RESTART,
        IEEE80211_RECONFIG_TYPE_SUSPEND
    };

.. _`ieee80211_reconfig_type.constants`:

Constants
---------

IEEE80211_RECONFIG_TYPE_RESTART
    hw restart type
    (also due to \ :c:func:`resume`\  callback returning 1)

IEEE80211_RECONFIG_TYPE_SUSPEND
    suspend type (regardless
    of wowlan configuration)

.. _`ieee80211_reconfig_type.description`:

Description
-----------

This enum is used by the \ :c:func:`reconfig_complete`\  callback to indicate what
reconfiguration type was completed.

.. _`ieee80211_ops`:

struct ieee80211_ops
====================

.. c:type:: struct ieee80211_ops

    callbacks from mac80211 to the driver

.. _`ieee80211_ops.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_ops {
        void (*tx)(struct ieee80211_hw *hw,struct ieee80211_tx_control *control,struct sk_buff *skb);
        int (*start)(struct ieee80211_hw *hw);
        void (*stop)(struct ieee80211_hw *hw);
        #ifdef CONFIG_PM
        int (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
        int (*resume)(struct ieee80211_hw *hw);
        void (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);
        #endif
        int (*add_interface)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*change_interface)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum nl80211_iftype new_type, bool p2p);
        void (*remove_interface)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*config)(struct ieee80211_hw *hw, u32 changed);
        void (*bss_info_changed)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_bss_conf *info,u32 changed);
        int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        u64 (*prepare_multicast)(struct ieee80211_hw *hw,struct netdev_hw_addr_list *mc_list);
        void (*configure_filter)(struct ieee80211_hw *hw,unsigned int changed_flags,unsigned int *total_flags,u64 multicast);
        void (*config_iface_filter)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,unsigned int filter_flags,unsigned int changed_flags);
        int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,bool set);
        int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,struct ieee80211_vif *vif, struct ieee80211_sta *sta,struct ieee80211_key_conf *key);
        void (*update_tkip_key)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct ieee80211_sta *sta,u32 iv32, u16 *phase1key);
        void (*set_rekey_data)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
        void (*set_default_unicast_key)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, int idx);
        int (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_scan_request *req);
        void (*cancel_hw_scan)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*sched_scan_start)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_sched_scan_request *req,struct ieee80211_scan_ies *ies);
        int (*sched_scan_stop)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        void (*sw_scan_start)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,const u8 *mac_addr);
        void (*sw_scan_complete)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*get_stats)(struct ieee80211_hw *hw,struct ieee80211_low_level_stats *stats);
        void (*get_key_seq)(struct ieee80211_hw *hw,struct ieee80211_key_conf *key,struct ieee80211_key_seq *seq);
        int (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);
        int (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);
        int (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
        int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
        #ifdef CONFIG_MAC80211_DEBUGFS
        void (*sta_add_debugfs)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
        void (*sta_remove_debugfs)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
        #endif
        void (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,enum sta_notify_cmd, struct ieee80211_sta *sta);
        int (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta,enum ieee80211_sta_state old_state,enum ieee80211_sta_state new_state);
        void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
        void (*sta_rc_update)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,u32 changed);
        void (*sta_rate_tbl_update)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
        void (*sta_statistics)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct station_info *sinfo);
        int (*conf_tx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 ac,const struct ieee80211_tx_queue_params *params);
        u64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        void (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,u64 tsf);
        void (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        int (*tx_last_beacon)(struct ieee80211_hw *hw);
        int (*ampdu_action)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_ampdu_params *params);
        int (*get_survey)(struct ieee80211_hw *hw, int idx,struct survey_info *survey);
        void (*rfkill_poll)(struct ieee80211_hw *hw);
        void (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);
        #ifdef CONFIG_NL80211_TESTMODE
        int (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,void *data, int len);
        int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
        #endif
        void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,u32 queues, bool drop);
        void (*channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel_switch *ch_switch);
        int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
        int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
        int (*remain_on_channel)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel *chan,int duration,enum ieee80211_roc_type type);
        int (*cancel_remain_on_channel)(struct ieee80211_hw *hw);
        int (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);
        void (*get_ringparam)(struct ieee80211_hw *hw,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
        bool (*tx_frames_pending)(struct ieee80211_hw *hw);
        int (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,const struct cfg80211_bitrate_mask *mask);
        void (*event_callback)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,const struct ieee80211_event *event);
        void (*allow_buffered_frames)(struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
        void (*release_buffered_frames)(struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
        int (*get_et_sset_count)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, int sset);
        void (*get_et_stats)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ethtool_stats *stats, u64 *data);
        void (*get_et_strings)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,u32 sset, u8 *data);
        void (*mgd_prepare_tx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        void (*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*add_chanctx)(struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
        void (*remove_chanctx)(struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
        void (*change_chanctx)(struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx,u32 changed);
        int (*assign_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
        void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
        int (*switch_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif_chanctx_switch *vifs,int n_vifs,enum ieee80211_chanctx_switch_mode mode);
        void (*reconfig_complete)(struct ieee80211_hw *hw,enum ieee80211_reconfig_type reconfig_type);
        #if IS_ENABLED(CONFIG_IPV6)
        void (*ipv6_addr_change)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct inet6_dev *idev);
        #endif
        void (*channel_switch_beacon)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_chan_def *chandef);
        int (*pre_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel_switch *ch_switch);
        int (*post_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif);
        int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
        u32 (*get_expected_throughput)(struct ieee80211_sta *sta);
        int (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,int *dbm);
        int (*tdls_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, u8 oper_class,struct cfg80211_chan_def *chandef,struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);
        void (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
        void (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_tdls_ch_sw_params *params);
        void (*wake_tx_queue)(struct ieee80211_hw *hw,struct ieee80211_txq *txq);
        void (*sync_rx_queues)(struct ieee80211_hw *hw);
    }

.. _`ieee80211_ops.members`:

Members
-------

tx
    Handler that 802.11 module calls for each transmitted frame.
    skb contains the buffer starting from the IEEE 802.11 header.
    The low-level driver should send the frame out based on
    configuration in the TX control data. This handler should,
    preferably, never fail and stop queues appropriately.
    Must be atomic.

start
    Called before the first netdevice attached to the hardware
    is enabled. This should turn on the hardware and must turn on
    frame reception (for possibly enabled monitor interfaces.)
    Returns negative error codes, these may be seen in userspace,
    or zero.
    When the device is started it should not have a MAC address
    to avoid acknowledging frames before a non-monitor device
    is added.
    Must be implemented and can sleep.

stop
    Called after last netdevice attached to the hardware
    is disabled. This should turn off the hardware (at least
    it must turn off frame reception.)
    May be called right after add_interface if that rejects
    an interface. If you added any work onto the mac80211 workqueue
    you should ensure to cancel it on this callback.
    Must be implemented and can sleep.

suspend
    Suspend the device; mac80211 itself will quiesce before and
    stop transmitting and doing any other configuration, and then
    ask the device to suspend. This is only invoked when WoWLAN is
    configured, otherwise the device is deconfigured completely and
    reconfigured at resume time.
    The driver may also impose special conditions under which it
    wants to use the "normal" suspend (deconfigure), say if it only
    supports WoWLAN when the device is associated. In this case, it
    must return 1 from this function.

resume
    If WoWLAN was configured, this indicates that mac80211 is
    now resuming its operation, after this the device must be fully
    functional again. If this returns an error, the only way out is
    to also unregister the device. If it returns 1, then mac80211
    will also go through the regular complete restart on resume.

set_wakeup
    Enable or disable wakeup when WoWLAN configuration is
    modified. The reason is that \ :c:func:`device_set_wakeup_enable`\  is
    supposed to be called when the configuration changes, not only
    in \ :c:func:`suspend`\ .

add_interface
    Called when a netdevice attached to the hardware is
    enabled. Because it is not called for monitor mode devices, \ ``start``\ 
    and \ ``stop``\  must be implemented.
    The driver should perform any initialization it needs before
    the device can be enabled. The initial configuration for the
    interface is given in the conf parameter.
    The callback may refuse to add an interface by returning a
    negative error code (which will be seen in userspace.)
    Must be implemented and can sleep.

change_interface
    Called when a netdevice changes type. This callback
    is optional, but only if it is supported can interface types be
    switched while the interface is UP. The callback may sleep.
    Note that while an interface is being switched, it will not be
    found by the interface iteration callbacks.

remove_interface
    Notifies a driver that an interface is going down.
    The \ ``stop``\  callback is called after this if it is the last interface
    and no monitor interfaces are present.
    When all interfaces are removed, the MAC address in the hardware
    must be cleared so the device no longer acknowledges packets,
    the mac_addr member of the conf structure is, however, set to the
    MAC address of the device going away.
    Hence, this callback must be implemented. It can sleep.

config
    Handler for configuration requests. IEEE 802.11 code calls this
    function to change hardware configuration, e.g., channel.
    This function should never fail but returns a negative error code
    if it does. The callback can sleep.

bss_info_changed
    Handler for configuration requests related to BSS
    parameters that may vary during BSS's lifespan, and may affect low
    level driver (e.g. assoc/disassoc status, erp parameters).
    This function should not be used if no BSS has been set, unless
    for association indication. The \ ``changed``\  parameter indicates which
    of the bss parameters has changed when a call is made. The callback
    can sleep.

start_ap
    Start operation on the AP interface, this is called after all the
    information in bss_conf is set and beacon can be retrieved. A channel
    context is bound before this is called. Note that if the driver uses
    software scan or ROC, this (and \ ``stop_ap``\ ) isn't called when the AP is
    just "paused" for scanning/ROC, which is indicated by the beacon being
    disabled/enabled via \ ``bss_info_changed``\ .

stop_ap
    Stop operation on the AP interface.

prepare_multicast
    Prepare for multicast filter configuration.
    This callback is optional, and its return value is passed
    to \ :c:func:`configure_filter`\ . This callback must be atomic.

configure_filter
    Configure the device's RX filter.
    See the section "Frame filtering" for more information.
    This callback must be implemented and can sleep.

config_iface_filter
    Configure the interface's RX filter.
    This callback is optional and is used to configure which frames
    should be passed to mac80211. The filter_flags is the combination
    of FIF\_\* flags. The changed_flags is a bit mask that indicates
    which flags are changed.
    This callback can sleep.

set_tim
    Set TIM bit. mac80211 calls this function when a TIM bit
    must be set or cleared for a given STA. Must be atomic.

set_key
    See the section "Hardware crypto acceleration"
    This callback is only called between add_interface and
    remove_interface calls, i.e. while the given virtual interface
    is enabled.
    Returns a negative error code if the key can't be added.
    The callback can sleep.

update_tkip_key
    See the section "Hardware crypto acceleration"
    This callback will be called in the context of Rx. Called for drivers
    which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
    The callback must be atomic.

set_rekey_data
    If the device supports GTK rekeying, for example while the
    host is suspended, it can assign this callback to retrieve the data
    necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
    After rekeying was done it should (for example during resume) notify
    userspace of the new replay counter using \ :c:func:`ieee80211_gtk_rekey_notify`\ .

set_default_unicast_key
    Set the default (unicast) key index, useful for
    WEP when the device sends data packets autonomously, e.g. for ARP
    offloading. The index can be 0-3, or -1 for unsetting it.

hw_scan
    Ask the hardware to service the scan request, no need to start
    the scan state machine in stack. The scan must honour the channel
    configuration done by the regulatory agent in the wiphy's
    registered bands. The hardware (or the driver) needs to make sure
    that power save is disabled.
    The \ ``req``\  ie/ie_len members are rewritten by mac80211 to contain the
    entire IEs after the SSID, so that drivers need not look at these
    at all but just send them after the SSID -- mac80211 includes the
    (extended) supported rates and HT information (where applicable).
    When the scan finishes, \ :c:func:`ieee80211_scan_completed`\  must be called;
    note that it also must be called when the scan cannot finish due to
    any error unless this callback returned a negative error code.
    The callback can sleep.

cancel_hw_scan
    Ask the low-level tp cancel the active hw scan.
    The driver should ask the hardware to cancel the scan (if possible),
    but the scan will be completed only after the driver will call
    \ :c:func:`ieee80211_scan_completed`\ .
    This callback is needed for wowlan, to prevent enqueueing a new
    scan_work after the low-level driver was already suspended.
    The callback can sleep.

sched_scan_start
    Ask the hardware to start scanning repeatedly at
    specific intervals.  The driver must call the
    \ :c:func:`ieee80211_sched_scan_results`\  function whenever it finds results.
    This process will continue until sched_scan_stop is called.

sched_scan_stop
    Tell the hardware to stop an ongoing scheduled scan.
    In this case, \ :c:func:`ieee80211_sched_scan_stopped`\  must not be called.

sw_scan_start
    Notifier function that is called just before a software scan
    is started. Can be NULL, if the driver doesn't need this notification.
    The mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,
    the driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it
    can use this parameter. The callback can sleep.

sw_scan_complete
    Notifier function that is called just after a
    software scan finished. Can be NULL, if the driver doesn't need
    this notification.
    The callback can sleep.

get_stats
    Return low-level statistics.
    Returns zero if statistics are available.
    The callback can sleep.

get_key_seq
    If your device implements encryption in hardware and does
    IV/PN assignment then this callback should be provided to read the
    IV/PN for the given key from hardware.
    The callback must be atomic.

set_frag_threshold
    Configuration of fragmentation threshold. Assign this
    if the device does fragmentation by itself; if this callback is
    implemented then the stack will not do fragmentation.
    The callback can sleep.

set_rts_threshold
    Configuration of RTS threshold (if device needs it)
    The callback can sleep.

sta_add
    Notifies low level driver about addition of an associated station,
    AP, IBSS/WDS/mesh peer etc. This callback can sleep.

sta_remove
    Notifies low level driver about removal of an associated
    station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
    returns it isn't safe to use the pointer, not even RCU protected;
    no RCU grace period is guaranteed between returning here and freeing
    the station. See \ ``sta_pre_rcu_remove``\  if needed.
    This callback can sleep.

sta_add_debugfs
    Drivers can use this callback to add debugfs files
    when a station is added to mac80211's station list. This callback
    and \ ``sta_remove_debugfs``\  should be within a CONFIG_MAC80211_DEBUGFS
    conditional. This callback can sleep.

sta_remove_debugfs
    Remove the debugfs files which were added using
    \ ``sta_add_debugfs``\ . This callback can sleep.

sta_notify
    Notifies low level driver about power state transition of an
    associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
    in AP mode, this callback will not be called when the flag
    \ ``IEEE80211_HW_AP_LINK_PS``\  is set. Must be atomic.

sta_state
    Notifies low level driver about state transition of a
    station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
    This callback is mutually exclusive with \ ``sta_add``\ /\ ``sta_remove``\ .
    It must not fail for down transitions but may fail for transitions
    up the list of states. Also note that after the callback returns it
    isn't safe to use the pointer, not even RCU protected - no RCU grace
    period is guaranteed between returning here and freeing the station.
    See \ ``sta_pre_rcu_remove``\  if needed.
    The callback can sleep.

sta_pre_rcu_remove
    Notify driver about station removal before RCU
    synchronisation. This is useful if a driver needs to have station
    pointers protected using RCU, it can then use this call to clear
    the pointers instead of waiting for an RCU grace period to elapse
    in \ ``sta_state``\ .
    The callback can sleep.

sta_rc_update
    Notifies the driver of changes to the bitrates that can be
    used to transmit to the station. The changes are advertised with bits
    from \ :c:type:`enum ieee80211_rate_control_changed <ieee80211_rate_control_changed>`\  and the values are reflected
    in the station data. This callback should only be used when the driver
    uses hardware rate control (\ ``IEEE80211_HW_HAS_RATE_CONTROL``\ ) since
    otherwise the rate control algorithm is notified directly.
    Must be atomic.

sta_rate_tbl_update
    Notifies the driver that the rate table changed. This
    is only used if the configured rate control algorithm actually uses
    the new rate table API, and is therefore optional. Must be atomic.

sta_statistics
    Get statistics for this station. For example with beacon
    filtering, the statistics kept by mac80211 might not be accurate, so
    let the driver pre-fill the statistics. The driver can fill most of
    the values (indicating which by setting the filled bitmap), but not
    all of them make sense - see the source for which ones are possible.
    Statistics that the driver doesn't fill will be filled by mac80211.
    The callback can sleep.

conf_tx
    Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
    bursting) for a hardware TX queue.
    Returns a negative error code on failure.
    The callback can sleep.

get_tsf
    Get the current TSF timer value from firmware/hardware. Currently,
    this is only used for IBSS mode BSSID merging and debugging. Is not a
    required function.
    The callback can sleep.

set_tsf
    Set the TSF timer to the specified value in the firmware/hardware.
    Currently, this is only used for IBSS mode debugging. Is not a
    required function.
    The callback can sleep.

reset_tsf
    Reset the TSF timer and allow firmware/hardware to synchronize
    with other STAs in the IBSS. This is only used in IBSS mode. This
    function is optional if the firmware/hardware takes full care of
    TSF synchronization.
    The callback can sleep.

tx_last_beacon
    Determine whether the last IBSS beacon was sent by us.
    This is needed only for IBSS mode and the result of this function is
    used to determine whether to reply to Probe Requests.
    Returns non-zero if this device sent the last beacon.
    The callback can sleep.

ampdu_action
    Perform a certain A-MPDU action
    The RA/TID combination determines the destination and TID we want
    the ampdu action to be performed for. The action is defined through
    ieee80211_ampdu_mlme_action.
    When the action is set to \ ``IEEE80211_AMPDU_TX_OPERATIONAL``\  the driver
    may neither send aggregates containing more subframes than \ ``buf_size``\ 
    nor send aggregates in a way that lost frames would exceed the
    buffer size. If just limiting the aggregate size, this would be

get_survey
    Return per-channel survey information

rfkill_poll
    Poll rfkill hardware state. If you need this, you also
    need to set wiphy->rfkill_poll to \ ``true``\  before registration,
    and need to call \ :c:func:`wiphy_rfkill_set_hw_state`\  in the callback.
    The callback can sleep.

set_coverage_class
    Set slot time for given coverage class as specified
    in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
    accordingly; coverage class equals to -1 to enable ACK timeout
    estimation algorithm (dynack). To disable dynack set valid value for
    coverage class. This callback is not required and may sleep.

testmode_cmd
    Implement a cfg80211 test mode command. The passed \ ``vif``\  may
    be \ ``NULL``\ . The callback can sleep.

testmode_dump
    Implement a cfg80211 test mode dump. The callback can sleep.

flush
    Flush all pending frames from the hardware queue, making sure
    that the hardware queues are empty. The \ ``queues``\  parameter is a bitmap
    of queues to flush, which is useful if different virtual interfaces
    use different hardware queues; it may also indicate all queues.
    If the parameter \ ``drop``\  is set to \ ``true``\ , pending frames may be dropped.
    Note that vif can be NULL.
    The callback can sleep.

channel_switch
    Drivers that need (or want) to offload the channel
    switch operation for CSAs received from the AP may implement this
    callback. They must then call \ :c:func:`ieee80211_chswitch_done`\  to indicate
    completion of the channel switch.

set_antenna
    Set antenna configuration (tx_ant, rx_ant) on the device.
    Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
    reject TX/RX mask combinations they cannot support by returning -EINVAL
    (also see nl80211.h \ ``NL80211_ATTR_WIPHY_ANTENNA_TX``\ ).

get_antenna
    Get current antenna configuration from device (tx_ant, rx_ant).

remain_on_channel
    Starts an off-channel period on the given channel, must
    call back to \ :c:func:`ieee80211_ready_on_channel`\  when on that channel. Note
    that normal channel traffic is not stopped as this is intended for hw
    offload. Frames to transmit on the off-channel channel are transmitted
    normally except for the \ ``IEEE80211_TX_CTL_TX_OFFCHAN``\  flag. When the
    duration (which will always be non-zero) expires, the driver must call
    \ :c:func:`ieee80211_remain_on_channel_expired`\ .
    Note that this callback may be called while the device is in IDLE and
    must be accepted in this case.
    This callback may sleep.

cancel_remain_on_channel
    Requests that an ongoing off-channel period is
    aborted before it expires. This callback may sleep.

set_ringparam
    Set tx and rx ring sizes.

get_ringparam
    Get tx and rx ring current and maximum sizes.

tx_frames_pending
    Check if there is any pending frame in the hardware
    queues before entering power save.

set_bitrate_mask
    Set a mask of rates to be used for rate control selection
    when transmitting a frame. Currently only legacy rates are handled.
    The callback can sleep.

event_callback
    Notify driver about any event in mac80211. See
    \ :c:type:`enum ieee80211_event_type <ieee80211_event_type>`\  for the different types.
    The callback must be atomic.

allow_buffered_frames
    Prepare device to allow the given number of frames
    to go out to the given station. The frames will be sent by mac80211
    via the usual TX path after this call. The TX information for frames
    released will also have the \ ``IEEE80211_TX_CTL_NO_PS_BUFFER``\  flag set
    and the last one will also have \ ``IEEE80211_TX_STATUS_EOSP``\  set. In case
    frames from multiple TIDs are released and the driver might reorder
    them between the TIDs, it must set the \ ``IEEE80211_TX_STATUS_EOSP``\  flag
    on the last frame and clear it on all others and also handle the EOSP
    bit in the QoS header correctly. Alternatively, it can also call the
    \ :c:func:`ieee80211_sta_eosp`\  function.
    The \ ``tids``\  parameter is a bitmap and tells the driver which TIDs the
    frames will be on; it will at most have two bits set.
    This callback must be atomic.

release_buffered_frames
    Release buffered frames according to the given
    parameters. In the case where the driver buffers some frames for
    sleeping stations mac80211 will use this callback to tell the driver
    to release some frames, either for PS-poll or uAPSD.
    Note that if the \ ``more_data``\  parameter is \ ``false``\  the driver must check
    if there are more frames on the given TIDs, and if there are more than
    the frames being released then it must still set the more-data bit in
    the frame. If the \ ``more_data``\  parameter is \ ``true``\ , then of course the
    more-data bit must always be set.
    The \ ``tids``\  parameter tells the driver which TIDs to release frames
    from, for PS-poll it will always have only a single bit set.
    In the case this is used for a PS-poll initiated release, the
    \ ``num_frames``\  parameter will always be 1 so code can be shared. In
    this case the driver must also set \ ``IEEE80211_TX_STATUS_EOSP``\  flag
    on the TX status (and must report TX status) so that the PS-poll
    period is properly ended. This is used to avoid sending multiple
    responses for a retried PS-poll frame.
    In the case this is used for uAPSD, the \ ``num_frames``\  parameter may be
    bigger than one, but the driver may send fewer frames (it must send
    at least one, however). In this case it is also responsible for
    setting the EOSP flag in the QoS header of the frames. Also, when the
    service period ends, the driver must set \ ``IEEE80211_TX_STATUS_EOSP``\ 
    on the last frame in the SP. Alternatively, it may call the function
    \ :c:func:`ieee80211_sta_eosp`\  to inform mac80211 of the end of the SP.
    This callback must be atomic.

get_et_sset_count
    Ethtool API to get string-set count.

get_et_stats
    Ethtool API to get a set of u64 stats.

get_et_strings
    Ethtool API to get a set of strings to describe stats
    and perhaps other supported types of ethtool data-sets.

mgd_prepare_tx
    Prepare for transmitting a management frame for association
    before associated. In multi-channel scenarios, a virtual interface is
    bound to a channel before it is associated, but as it isn't associated
    yet it need not necessarily be given airtime, in particular since any
    transmission to a P2P GO needs to be synchronized against the GO's
    powersave state. mac80211 will call this function before transmitting a
    management frame prior to having successfully associated to allow the
    driver to give it channel time for the transmission, to get a response
    and to be able to synchronize with the GO.
    The callback will be called before each transmission and upon return
    mac80211 will transmit the frame right away.
    The callback is optional and can (should!) sleep.

mgd_protect_tdls_discover
    Protect a TDLS discovery session. After sending
    a TDLS discovery-request, we expect a reply to arrive on the AP's
    channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
    setup-response is a direct packet not buffered by the AP.
    mac80211 will call this function just before the transmission of a TDLS
    discovery-request. The recommended period of protection is at least
    2 \* (DTIM period).
    The callback is optional and can sleep.

add_chanctx
    Notifies device driver about new channel context creation.
    This callback may sleep.

remove_chanctx
    Notifies device driver about channel context destruction.
    This callback may sleep.

change_chanctx
    Notifies device driver about channel context changes that
    may happen when combining different virtual interfaces on the same
    channel context with different settings
    This callback may sleep.

assign_vif_chanctx
    Notifies device driver about channel context being bound
    to vif. Possible use is for hw queue remapping.
    This callback may sleep.

unassign_vif_chanctx
    Notifies device driver about channel context being
    unbound from vif.
    This callback may sleep.

switch_vif_chanctx
    switch a number of vifs from one chanctx to
    another, as specified in the list of
    \ ``ieee80211_vif_chanctx_switch``\  passed to the driver, according
    to the mode defined in \ :c:type:`struct ieee80211_chanctx_switch_mode <ieee80211_chanctx_switch_mode>`.
    This callback may sleep.

reconfig_complete
    Called after a call to \ :c:func:`ieee80211_restart_hw`\  and
    during resume, when the reconfiguration has completed.
    This can help the driver implement the reconfiguration step (and
    indicate mac80211 is ready to receive frames).
    This callback may sleep.

ipv6_addr_change
    IPv6 address assignment on the given interface changed.
    Currently, this is only called for managed or P2P client interfaces.
    This callback is optional; it must not sleep.

channel_switch_beacon
    Starts a channel switch to a new channel.
    Beacons are modified to include CSA or ECSA IEs before calling this
    function. The corresponding count fields in these IEs must be
    decremented, and when they reach 1 the driver must call
    \ :c:func:`ieee80211_csa_finish`\ . Drivers which use \ :c:func:`ieee80211_beacon_get`\ 
    get the csa counter decremented by mac80211, but must check if it is
    1 using \ :c:func:`ieee80211_csa_is_complete`\  after the beacon has been
    transmitted and then call \ :c:func:`ieee80211_csa_finish`\ .
    If the CSA count starts as zero or 1, this function will not be called,
    since there won't be any time to beacon before the switch anyway.

pre_channel_switch
    This is an optional callback that is called
    before a channel switch procedure is started (ie. when a STA
    gets a CSA or an userspace initiated channel-switch), allowing
    the driver to prepare for the channel switch.

post_channel_switch
    This is an optional callback that is called
    after a channel switch procedure is completed, allowing the
    driver to go back to a normal configuration.

join_ibss
    Join an IBSS (on an IBSS interface); this is called after all
    information in bss_conf is set up and the beacon can be retrieved. A
    channel context is bound before this is called.

leave_ibss
    Leave the IBSS again.

get_expected_throughput
    extract the expected throughput towards the
    specified station. The returned value is expressed in Kbps. It returns 0
    if the RC algorithm does not have proper data to provide.

get_txpower
    get current maximum tx power (in dBm) based on configuration
    and hardware limits.

tdls_channel_switch
    Start channel-switching with a TDLS peer. The driver
    is responsible for continually initiating channel-switching operations
    and returning to the base channel for communication with the AP. The
    driver receives a channel-switch request template and the location of
    the switch-timing IE within the template as part of the invocation.
    The template is valid only within the call, and the driver can
    optionally copy the skb for further re-use.

tdls_cancel_channel_switch
    Stop channel-switching with a TDLS peer. Both
    peers must be on the base channel when the call completes.

tdls_recv_channel_switch
    a TDLS channel-switch related frame (request or
    response) has been received from a remote peer. The driver gets
    parameters parsed from the incoming frame and may use them to continue
    an ongoing channel-switch operation. In addition, a channel-switch
    response template is provided, together with the location of the
    switch-timing IE within the template. The skb can only be used within
    the function call.

wake_tx_queue
    Called when new packets have been added to the queue.

sync_rx_queues
    Process all pending frames in RSS queues. This is a
    synchronization which is needed in case driver has in its RSS queues
    pending frames that were received prior to the control path action
    currently taken (e.g. disassociation) but are not processed yet.

.. _`ieee80211_ops.description`:

Description
-----------

This structure contains various callbacks that the driver may
handle or, in some cases, must handle, for example to configure
the hardware to a new channel or to transmit a frame.

.. _`ieee80211_ops.possible-with-a-buf_size-of-8`:

possible with a buf_size of 8
-----------------------------

- TX: 1.....7
- RX:  2....7 (lost frame #1)
- TX:        8..1...
which is invalid since #1 was now re-transmitted well past the
buffer size of 8. Correct ways to retransmit #1 would be:
- TX:       1 or 18 or 81
Even "189" would be wrong since 1 could be lost again.

Returns a negative error code on failure.
The callback can sleep.

.. _`ieee80211_alloc_hw_nm`:

ieee80211_alloc_hw_nm
=====================

.. c:function:: struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len, const struct ieee80211_ops *ops, const char *requested_name)

    Allocate a new hardware device

    :param size_t priv_data_len:
        length of private data

    :param const struct ieee80211_ops \*ops:
        callbacks for this device

    :param const char \*requested_name:
        Requested name for this device.
        NULL is valid value, and means use the default naming (phy\ ``d``\ )

.. _`ieee80211_alloc_hw_nm.description`:

Description
-----------

This must be called once for each hardware device. The returned pointer
must be used to refer to this device when calling other functions.
mac80211 allocates a private data area for the driver pointed to by
\ ``priv``\  in \ :c:type:`struct ieee80211_hw <ieee80211_hw>`\ , the size of this area is given as
\ ``priv_data_len``\ .

.. _`ieee80211_alloc_hw_nm.return`:

Return
------

A pointer to the new hardware device, or \ ``NULL``\  on error.

.. _`ieee80211_alloc_hw`:

ieee80211_alloc_hw
==================

.. c:function:: struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len, const struct ieee80211_ops *ops)

    Allocate a new hardware device

    :param size_t priv_data_len:
        length of private data

    :param const struct ieee80211_ops \*ops:
        callbacks for this device

.. _`ieee80211_alloc_hw.description`:

Description
-----------

This must be called once for each hardware device. The returned pointer
must be used to refer to this device when calling other functions.
mac80211 allocates a private data area for the driver pointed to by
\ ``priv``\  in \ :c:type:`struct ieee80211_hw <ieee80211_hw>`\ , the size of this area is given as
\ ``priv_data_len``\ .

.. _`ieee80211_alloc_hw.return`:

Return
------

A pointer to the new hardware device, or \ ``NULL``\  on error.

.. _`ieee80211_register_hw`:

ieee80211_register_hw
=====================

.. c:function:: int ieee80211_register_hw(struct ieee80211_hw *hw)

    Register hardware device

    :param struct ieee80211_hw \*hw:
        the device to register as returned by \ :c:func:`ieee80211_alloc_hw`\ 

.. _`ieee80211_register_hw.description`:

Description
-----------

You must call this function before any other functions in
mac80211. Note that before a hardware can be registered, you
need to fill the contained wiphy's information.

.. _`ieee80211_register_hw.return`:

Return
------

0 on success. An error code otherwise.

.. _`ieee80211_tpt_blink`:

struct ieee80211_tpt_blink
==========================

.. c:type:: struct ieee80211_tpt_blink

    throughput blink description

.. _`ieee80211_tpt_blink.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tpt_blink {
        int throughput;
        int blink_time;
    }

.. _`ieee80211_tpt_blink.members`:

Members
-------

throughput
    throughput in Kbit/sec

blink_time
    blink time in milliseconds
    (full cycle, ie. one off + one on period)

.. _`ieee80211_tpt_led_trigger_flags`:

enum ieee80211_tpt_led_trigger_flags
====================================

.. c:type:: enum ieee80211_tpt_led_trigger_flags

    throughput trigger flags

.. _`ieee80211_tpt_led_trigger_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_tpt_led_trigger_flags {
        IEEE80211_TPT_LEDTRIG_FL_RADIO,
        IEEE80211_TPT_LEDTRIG_FL_WORK,
        IEEE80211_TPT_LEDTRIG_FL_CONNECTED
    };

.. _`ieee80211_tpt_led_trigger_flags.constants`:

Constants
---------

IEEE80211_TPT_LEDTRIG_FL_RADIO
    enable blinking with radio

IEEE80211_TPT_LEDTRIG_FL_WORK
    enable blinking when working

IEEE80211_TPT_LEDTRIG_FL_CONNECTED
    enable blinking when at least one
    interface is connected in some way, including being an AP

.. _`ieee80211_get_tx_led_name`:

ieee80211_get_tx_led_name
=========================

.. c:function:: const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)

    get name of TX LED

    :param struct ieee80211_hw \*hw:
        the hardware to get the LED trigger name for

.. _`ieee80211_get_tx_led_name.description`:

Description
-----------

mac80211 creates a transmit LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \ ``NULL``\  if not configured for LEDs)
of the trigger so you can automatically link the LED device.

.. _`ieee80211_get_tx_led_name.return`:

Return
------

The name of the LED trigger. \ ``NULL``\  if not configured for LEDs.

.. _`ieee80211_get_rx_led_name`:

ieee80211_get_rx_led_name
=========================

.. c:function:: const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)

    get name of RX LED

    :param struct ieee80211_hw \*hw:
        the hardware to get the LED trigger name for

.. _`ieee80211_get_rx_led_name.description`:

Description
-----------

mac80211 creates a receive LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \ ``NULL``\  if not configured for LEDs)
of the trigger so you can automatically link the LED device.

.. _`ieee80211_get_rx_led_name.return`:

Return
------

The name of the LED trigger. \ ``NULL``\  if not configured for LEDs.

.. _`ieee80211_get_assoc_led_name`:

ieee80211_get_assoc_led_name
============================

.. c:function:: const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)

    get name of association LED

    :param struct ieee80211_hw \*hw:
        the hardware to get the LED trigger name for

.. _`ieee80211_get_assoc_led_name.description`:

Description
-----------

mac80211 creates a association LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \ ``NULL``\  if not configured for LEDs)
of the trigger so you can automatically link the LED device.

.. _`ieee80211_get_assoc_led_name.return`:

Return
------

The name of the LED trigger. \ ``NULL``\  if not configured for LEDs.

.. _`ieee80211_get_radio_led_name`:

ieee80211_get_radio_led_name
============================

.. c:function:: const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)

    get name of radio LED

    :param struct ieee80211_hw \*hw:
        the hardware to get the LED trigger name for

.. _`ieee80211_get_radio_led_name.description`:

Description
-----------

mac80211 creates a radio change LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \ ``NULL``\  if not configured for LEDs)
of the trigger so you can automatically link the LED device.

.. _`ieee80211_get_radio_led_name.return`:

Return
------

The name of the LED trigger. \ ``NULL``\  if not configured for LEDs.

.. _`ieee80211_create_tpt_led_trigger`:

ieee80211_create_tpt_led_trigger
================================

.. c:function:: const char *ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags, const struct ieee80211_tpt_blink *blink_table, unsigned int blink_table_len)

    create throughput LED trigger

    :param struct ieee80211_hw \*hw:
        the hardware to create the trigger for

    :param unsigned int flags:
        trigger flags, see \ :c:type:`enum ieee80211_tpt_led_trigger_flags <ieee80211_tpt_led_trigger_flags>`\ 

    :param const struct ieee80211_tpt_blink \*blink_table:
        the blink table -- needs to be ordered by throughput

    :param unsigned int blink_table_len:
        size of the blink table

.. _`ieee80211_create_tpt_led_trigger.return`:

Return
------

\ ``NULL``\  (in case of error, or if no LED triggers are
configured) or the name of the new trigger.

.. _`ieee80211_create_tpt_led_trigger.note`:

Note
----

This function must be called before \ :c:func:`ieee80211_register_hw`\ .

.. _`ieee80211_unregister_hw`:

ieee80211_unregister_hw
=======================

.. c:function:: void ieee80211_unregister_hw(struct ieee80211_hw *hw)

    Unregister a hardware device

    :param struct ieee80211_hw \*hw:
        the hardware to unregister

.. _`ieee80211_unregister_hw.description`:

Description
-----------

This function instructs mac80211 to free allocated resources
and unregister netdevices from the networking subsystem.

.. _`ieee80211_free_hw`:

ieee80211_free_hw
=================

.. c:function:: void ieee80211_free_hw(struct ieee80211_hw *hw)

    free hardware descriptor

    :param struct ieee80211_hw \*hw:
        the hardware to free

.. _`ieee80211_free_hw.description`:

Description
-----------

This function frees everything that was allocated, including the
private data for the driver. You must call \ :c:func:`ieee80211_unregister_hw`\ 
before calling this function.

.. _`ieee80211_restart_hw`:

ieee80211_restart_hw
====================

.. c:function:: void ieee80211_restart_hw(struct ieee80211_hw *hw)

    restart hardware completely

    :param struct ieee80211_hw \*hw:
        the hardware to restart

.. _`ieee80211_restart_hw.description`:

Description
-----------

Call this function when the hardware was restarted for some reason
(hardware error, ...) and the driver is unable to restore its state
by itself. mac80211 assumes that at this point the driver/hardware
is completely uninitialised and stopped, it starts the process by
calling the ->\ :c:func:`start`\  operation. The driver will need to reset all
internal state that it has prior to calling this function.

.. _`ieee80211_rx_napi`:

ieee80211_rx_napi
=================

.. c:function:: void ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta, struct sk_buff *skb, struct napi_struct *napi)

    receive frame from NAPI context

    :param struct ieee80211_hw \*hw:
        the hardware this frame came in on

    :param struct ieee80211_sta \*sta:
        the station the frame was received from, or \ ``NULL``\ 

    :param struct sk_buff \*skb:
        the buffer to receive, owned by mac80211 after this call

    :param struct napi_struct \*napi:
        the NAPI context

.. _`ieee80211_rx_napi.description`:

Description
-----------

Use this function to hand received frames to mac80211. The receive
buffer in \ ``skb``\  must start with an IEEE 802.11 header. In case of a
paged \ ``skb``\  is used, the driver is recommended to put the ieee80211
header of the frame on the linear part of the \ ``skb``\  to avoid memory
allocation and/or memcpy by the stack.

This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls to
this function, \ :c:func:`ieee80211_rx_ni`\  and \ :c:func:`ieee80211_rx_irqsafe`\  may not be
mixed for a single hardware. Must not run concurrently with
\ :c:func:`ieee80211_tx_status`\  or \ :c:func:`ieee80211_tx_status_ni`\ .

This function must be called with BHs disabled.

.. _`ieee80211_rx`:

ieee80211_rx
============

.. c:function:: void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)

    receive frame

    :param struct ieee80211_hw \*hw:
        the hardware this frame came in on

    :param struct sk_buff \*skb:
        the buffer to receive, owned by mac80211 after this call

.. _`ieee80211_rx.description`:

Description
-----------

Use this function to hand received frames to mac80211. The receive
buffer in \ ``skb``\  must start with an IEEE 802.11 header. In case of a
paged \ ``skb``\  is used, the driver is recommended to put the ieee80211
header of the frame on the linear part of the \ ``skb``\  to avoid memory
allocation and/or memcpy by the stack.

This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls to
this function, \ :c:func:`ieee80211_rx_ni`\  and \ :c:func:`ieee80211_rx_irqsafe`\  may not be
mixed for a single hardware. Must not run concurrently with
\ :c:func:`ieee80211_tx_status`\  or \ :c:func:`ieee80211_tx_status_ni`\ .

In process context use instead \ :c:func:`ieee80211_rx_ni`\ .

.. _`ieee80211_rx_irqsafe`:

ieee80211_rx_irqsafe
====================

.. c:function:: void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)

    receive frame

    :param struct ieee80211_hw \*hw:
        the hardware this frame came in on

    :param struct sk_buff \*skb:
        the buffer to receive, owned by mac80211 after this call

.. _`ieee80211_rx_irqsafe.description`:

Description
-----------

Like \ :c:func:`ieee80211_rx`\  but can be called in IRQ context
(internally defers to a tasklet.)

Calls to this function, \ :c:func:`ieee80211_rx`\  or \ :c:func:`ieee80211_rx_ni`\  may not
be mixed for a single hardware.Must not run concurrently with
\ :c:func:`ieee80211_tx_status`\  or \ :c:func:`ieee80211_tx_status_ni`\ .

.. _`ieee80211_rx_ni`:

ieee80211_rx_ni
===============

.. c:function:: void ieee80211_rx_ni(struct ieee80211_hw *hw, struct sk_buff *skb)

    receive frame (in process context)

    :param struct ieee80211_hw \*hw:
        the hardware this frame came in on

    :param struct sk_buff \*skb:
        the buffer to receive, owned by mac80211 after this call

.. _`ieee80211_rx_ni.description`:

Description
-----------

Like \ :c:func:`ieee80211_rx`\  but can be called in process context
(internally disables bottom halves).

Calls to this function, \ :c:func:`ieee80211_rx`\  and \ :c:func:`ieee80211_rx_irqsafe`\  may
not be mixed for a single hardware. Must not run concurrently with
\ :c:func:`ieee80211_tx_status`\  or \ :c:func:`ieee80211_tx_status_ni`\ .

.. _`ieee80211_sta_ps_transition`:

ieee80211_sta_ps_transition
===========================

.. c:function:: int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start)

    PS transition for connected sta

    :param struct ieee80211_sta \*sta:
        currently connected sta

    :param bool start:
        start or stop PS

.. _`ieee80211_sta_ps_transition.description`:

Description
-----------

When operating in AP mode with the \ ``IEEE80211_HW_AP_LINK_PS``\ 
flag set, use this function to inform mac80211 about a connected station
entering/leaving PS mode.

This function may not be called in IRQ context or with softirqs enabled.

Calls to this function for a single hardware must be synchronized against
each other.

.. _`ieee80211_sta_ps_transition.return`:

Return
------

0 on success. -EINVAL when the requested PS mode is already set.

.. _`ieee80211_sta_ps_transition_ni`:

ieee80211_sta_ps_transition_ni
==============================

.. c:function:: int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta, bool start)

    PS transition for connected sta (in process context)

    :param struct ieee80211_sta \*sta:
        currently connected sta

    :param bool start:
        start or stop PS

.. _`ieee80211_sta_ps_transition_ni.description`:

Description
-----------

Like \ :c:func:`ieee80211_sta_ps_transition`\  but can be called in process context
(internally disables bottom halves). Concurrent call restriction still
applies.

.. _`ieee80211_sta_ps_transition_ni.return`:

Return
------

Like \ :c:func:`ieee80211_sta_ps_transition`\ .

.. _`ieee80211_sta_pspoll`:

ieee80211_sta_pspoll
====================

.. c:function:: void ieee80211_sta_pspoll(struct ieee80211_sta *sta)

    PS-Poll frame received

    :param struct ieee80211_sta \*sta:
        currently connected station

.. _`ieee80211_sta_pspoll.description`:

Description
-----------

When operating in AP mode with the \ ``IEEE80211_HW_AP_LINK_PS``\  flag set,
use this function to inform mac80211 that a PS-Poll frame from a
connected station was received.
This must be used in conjunction with \ :c:func:`ieee80211_sta_ps_transition`\ 
and possibly \ :c:func:`ieee80211_sta_uapsd_trigger`\ ; calls to all three must
be serialized.

.. _`ieee80211_sta_uapsd_trigger`:

ieee80211_sta_uapsd_trigger
===========================

.. c:function:: void ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid)

    (potential) U-APSD trigger frame received

    :param struct ieee80211_sta \*sta:
        currently connected station

    :param u8 tid:
        TID of the received (potential) trigger frame

.. _`ieee80211_sta_uapsd_trigger.description`:

Description
-----------

When operating in AP mode with the \ ``IEEE80211_HW_AP_LINK_PS``\  flag set,
use this function to inform mac80211 that a (potential) trigger frame
from a connected station was received.
This must be used in conjunction with \ :c:func:`ieee80211_sta_ps_transition`\ 
and possibly \ :c:func:`ieee80211_sta_pspoll`\ ; calls to all three must be
serialized.

.. _`ieee80211_sta_set_buffered`:

ieee80211_sta_set_buffered
==========================

.. c:function:: void ieee80211_sta_set_buffered(struct ieee80211_sta *sta, u8 tid, bool buffered)

    inform mac80211 about driver-buffered frames

    :param struct ieee80211_sta \*sta:
        \ :c:type:`struct ieee80211_sta <ieee80211_sta>`\  pointer for the sleeping station

    :param u8 tid:
        the TID that has buffered frames

    :param bool buffered:
        indicates whether or not frames are buffered for this TID

.. _`ieee80211_sta_set_buffered.description`:

Description
-----------

If a driver buffers frames for a powersave station instead of passing
them back to mac80211 for retransmission, the station may still need
to be told that there are buffered frames via the TIM bit.

This function informs mac80211 whether or not there are frames that are
buffered in the driver for a given TID; mac80211 can then use this data
to set the TIM bit (NOTE: This may call back into the driver's set_tim
call! Beware of the locking!)

If all frames are released to the station (due to PS-poll or uAPSD)
then the driver needs to inform mac80211 that there no longer are
frames buffered. However, when the station wakes up mac80211 assumes
that all buffered frames will be transmitted and clears this data,
drivers need to make sure they inform mac80211 about all buffered
frames on the sleep transition (\ :c:func:`sta_notify`\  with \ ``STA_NOTIFY_SLEEP``\ ).

Note that technically mac80211 only needs to know this per AC, not per
TID, but since driver buffering will inevitably happen per TID (since
it is related to aggregation) it is easier to make mac80211 map the
TID to the AC as required instead of keeping track in all drivers that
use this API.

.. _`ieee80211_get_tx_rates`:

ieee80211_get_tx_rates
======================

.. c:function:: void ieee80211_get_tx_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct sk_buff *skb, struct ieee80211_tx_rate *dest, int max_rates)

    get the selected transmit rates for a packet

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param struct ieee80211_sta \*sta:
        the receiver station to which this packet is sent.

    :param struct sk_buff \*skb:
        the frame to be transmitted.

    :param struct ieee80211_tx_rate \*dest:
        buffer for extracted rate/retry information

    :param int max_rates:
        maximum number of rates to fetch

.. _`ieee80211_get_tx_rates.description`:

Description
-----------

Call this function in a driver with per-packet rate selection support
to combine the rate info in the packet tx info with the most recent
rate selection table for the station entry.

.. _`ieee80211_tx_status`:

ieee80211_tx_status
===================

.. c:function:: void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)

    transmit status callback

    :param struct ieee80211_hw \*hw:
        the hardware the frame was transmitted by

    :param struct sk_buff \*skb:
        the frame that was transmitted, owned by mac80211 after this call

.. _`ieee80211_tx_status.description`:

Description
-----------

Call this function for all transmitted frames after they have been
transmitted. It is permissible to not call this function for
multicast frames but this can affect statistics.

This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls
to this function, \ :c:func:`ieee80211_tx_status_ni`\  and \ :c:func:`ieee80211_tx_status_irqsafe`\ 
may not be mixed for a single hardware. Must not run concurrently with
\ :c:func:`ieee80211_rx`\  or \ :c:func:`ieee80211_rx_ni`\ .

.. _`ieee80211_tx_status_noskb`:

ieee80211_tx_status_noskb
=========================

.. c:function:: void ieee80211_tx_status_noskb(struct ieee80211_hw *hw, struct ieee80211_sta *sta, struct ieee80211_tx_info *info)

    transmit status callback without skb

    :param struct ieee80211_hw \*hw:
        the hardware the frame was transmitted by

    :param struct ieee80211_sta \*sta:
        the receiver station to which this packet is sent
        (NULL for multicast packets)

    :param struct ieee80211_tx_info \*info:
        tx status information

.. _`ieee80211_tx_status_noskb.description`:

Description
-----------

This function can be used as a replacement for ieee80211_tx_status
in drivers that cannot reliably map tx status information back to
specific skbs.

Calls to this function for a single hardware must be synchronized
against each other. Calls to this function, \ :c:func:`ieee80211_tx_status_ni`\ 
and \ :c:func:`ieee80211_tx_status_irqsafe`\  may not be mixed for a single hardware.

.. _`ieee80211_tx_status_ni`:

ieee80211_tx_status_ni
======================

.. c:function:: void ieee80211_tx_status_ni(struct ieee80211_hw *hw, struct sk_buff *skb)

    transmit status callback (in process context)

    :param struct ieee80211_hw \*hw:
        the hardware the frame was transmitted by

    :param struct sk_buff \*skb:
        the frame that was transmitted, owned by mac80211 after this call

.. _`ieee80211_tx_status_ni.description`:

Description
-----------

Like \ :c:func:`ieee80211_tx_status`\  but can be called in process context.

Calls to this function, \ :c:func:`ieee80211_tx_status`\  and
\ :c:func:`ieee80211_tx_status_irqsafe`\  may not be mixed
for a single hardware.

.. _`ieee80211_tx_status_irqsafe`:

ieee80211_tx_status_irqsafe
===========================

.. c:function:: void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)

    IRQ-safe transmit status callback

    :param struct ieee80211_hw \*hw:
        the hardware the frame was transmitted by

    :param struct sk_buff \*skb:
        the frame that was transmitted, owned by mac80211 after this call

.. _`ieee80211_tx_status_irqsafe.description`:

Description
-----------

Like \ :c:func:`ieee80211_tx_status`\  but can be called in IRQ context
(internally defers to a tasklet.)

Calls to this function, \ :c:func:`ieee80211_tx_status`\  and
\ :c:func:`ieee80211_tx_status_ni`\  may not be mixed for a single hardware.

.. _`ieee80211_report_low_ack`:

ieee80211_report_low_ack
========================

.. c:function:: void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets)

    report non-responding station

    :param struct ieee80211_sta \*sta:
        the non-responding connected sta

    :param u32 num_packets:
        number of packets sent to \ ``sta``\  without a response

.. _`ieee80211_report_low_ack.description`:

Description
-----------

When operating in AP-mode, call this function to report a non-responding
connected STA.

.. _`ieee80211_mutable_offsets`:

struct ieee80211_mutable_offsets
================================

.. c:type:: struct ieee80211_mutable_offsets

    mutable beacon offsets

.. _`ieee80211_mutable_offsets.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_mutable_offsets {
        u16 tim_offset;
        u16 tim_length;
        u16 csa_counter_offs[IEEE80211_MAX_CSA_COUNTERS_NUM];
    }

.. _`ieee80211_mutable_offsets.members`:

Members
-------

tim_offset
    position of TIM element

tim_length
    size of TIM element

csa_counter_offs
    array of IEEE80211_MAX_CSA_COUNTERS_NUM offsets
    to CSA counters.  This array can contain zero values which
    should be ignored.

.. _`ieee80211_beacon_get_template`:

ieee80211_beacon_get_template
=============================

.. c:function:: struct sk_buff *ieee80211_beacon_get_template(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_mutable_offsets *offs)

    beacon template generation function

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param struct ieee80211_mutable_offsets \*offs:
        \ :c:type:`struct ieee80211_mutable_offsets <ieee80211_mutable_offsets>`\  pointer to struct that will
        receive the offsets that may be updated by the driver.

.. _`ieee80211_beacon_get_template.description`:

Description
-----------

If the driver implements beaconing modes, it must use this function to
obtain the beacon template.

This function should be used if the beacon frames are generated by the
device, and then the driver must use the returned beacon as the template
The driver or the device are responsible to update the DTIM and, when
applicable, the CSA count.

The driver is responsible for freeing the returned skb.

.. _`ieee80211_beacon_get_template.return`:

Return
------

The beacon template. \ ``NULL``\  on error.

.. _`ieee80211_beacon_get_tim`:

ieee80211_beacon_get_tim
========================

.. c:function:: struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u16 *tim_offset, u16 *tim_length)

    beacon generation function

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param u16 \*tim_offset:
        pointer to variable that will receive the TIM IE offset.
        Set to 0 if invalid (in non-AP modes).

    :param u16 \*tim_length:
        pointer to variable that will receive the TIM IE length,
        (including the ID and length bytes!).
        Set to 0 if invalid (in non-AP modes).

.. _`ieee80211_beacon_get_tim.description`:

Description
-----------

If the driver implements beaconing modes, it must use this function to
obtain the beacon frame.

If the beacon frames are generated by the host system (i.e., not in
hardware/firmware), the driver uses this function to get each beacon
frame from mac80211 -- it is responsible for calling this function exactly
once before the beacon is needed (e.g. based on hardware interrupt).

The driver is responsible for freeing the returned skb.

.. _`ieee80211_beacon_get_tim.return`:

Return
------

The beacon template. \ ``NULL``\  on error.

.. _`ieee80211_beacon_get`:

ieee80211_beacon_get
====================

.. c:function:: struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    beacon generation function

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_beacon_get.description`:

Description
-----------

See \ :c:func:`ieee80211_beacon_get_tim`\ .

.. _`ieee80211_beacon_get.return`:

Return
------

See \ :c:func:`ieee80211_beacon_get_tim`\ .

.. _`ieee80211_csa_update_counter`:

ieee80211_csa_update_counter
============================

.. c:function:: u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif)

    request mac80211 to decrement the csa counter

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_csa_update_counter.description`:

Description
-----------

The csa counter should be updated after each beacon transmission.
This function is called implicitly when
ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
beacon frames are generated by the device, the driver should call this
function after each beacon transmission to sync mac80211's csa counters.

.. _`ieee80211_csa_update_counter.return`:

Return
------

new csa counter value

.. _`ieee80211_csa_finish`:

ieee80211_csa_finish
====================

.. c:function:: void ieee80211_csa_finish(struct ieee80211_vif *vif)

    notify mac80211 about channel switch

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_csa_finish.description`:

Description
-----------

After a channel switch announcement was scheduled and the counter in this
announcement hits 1, this function must be called by the driver to
notify mac80211 that the channel can be changed.

.. _`ieee80211_csa_is_complete`:

ieee80211_csa_is_complete
=========================

.. c:function:: bool ieee80211_csa_is_complete(struct ieee80211_vif *vif)

    find out if counters reached 1

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_csa_is_complete.description`:

Description
-----------

This function returns whether the channel switch counters reached zero.

.. _`ieee80211_proberesp_get`:

ieee80211_proberesp_get
=======================

.. c:function:: struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    retrieve a Probe Response template

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_proberesp_get.description`:

Description
-----------

Creates a Probe Response template which can, for example, be uploaded to
hardware. The destination address should be set by the caller.

Can only be called in AP mode.

.. _`ieee80211_proberesp_get.return`:

Return
------

The Probe Response template. \ ``NULL``\  on error.

.. _`ieee80211_pspoll_get`:

ieee80211_pspoll_get
====================

.. c:function:: struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    retrieve a PS Poll template

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_pspoll_get.description`:

Description
-----------

Creates a PS Poll a template which can, for example, uploaded to
hardware. The template must be updated after association so that correct
AID, BSSID and MAC address is used.

.. _`ieee80211_pspoll_get.note`:

Note
----

Caller (or hardware) is responsible for setting the
\ :c:type:`struct IEEE80211_FCTL_PM <IEEE80211_FCTL_PM>` bit.

.. _`ieee80211_pspoll_get.return`:

Return
------

The PS Poll template. \ ``NULL``\  on error.

.. _`ieee80211_nullfunc_get`:

ieee80211_nullfunc_get
======================

.. c:function:: struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    retrieve a nullfunc template

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_nullfunc_get.description`:

Description
-----------

Creates a Nullfunc template which can, for example, uploaded to
hardware. The template must be updated after association so that correct
BSSID and address is used.

.. _`ieee80211_nullfunc_get.note`:

Note
----

Caller (or hardware) is responsible for setting the
\ :c:type:`struct IEEE80211_FCTL_PM <IEEE80211_FCTL_PM>` bit as well as Duration and Sequence Control fields.

.. _`ieee80211_nullfunc_get.return`:

Return
------

The nullfunc template. \ ``NULL``\  on error.

.. _`ieee80211_probereq_get`:

ieee80211_probereq_get
======================

.. c:function:: struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw, const u8 *src_addr, const u8 *ssid, size_t ssid_len, size_t tailroom)

    retrieve a Probe Request template

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param const u8 \*src_addr:
        source MAC address

    :param const u8 \*ssid:
        SSID buffer

    :param size_t ssid_len:
        length of SSID

    :param size_t tailroom:
        tailroom to reserve at end of SKB for IEs

.. _`ieee80211_probereq_get.description`:

Description
-----------

Creates a Probe Request template which can, for example, be uploaded to
hardware.

.. _`ieee80211_probereq_get.return`:

Return
------

The Probe Request template. \ ``NULL``\  on error.

.. _`ieee80211_rts_get`:

ieee80211_rts_get
=================

.. c:function:: void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif, const void *frame, size_t frame_len, const struct ieee80211_tx_info *frame_txctl, struct ieee80211_rts *rts)

    RTS frame generation function

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param const void \*frame:
        pointer to the frame that is going to be protected by the RTS.

    :param size_t frame_len:
        the frame length (in octets).

    :param const struct ieee80211_tx_info \*frame_txctl:
        \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  of the frame.

    :param struct ieee80211_rts \*rts:
        The buffer where to store the RTS frame.

.. _`ieee80211_rts_get.description`:

Description
-----------

If the RTS frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next RTS frame from the 802.11 code. The low-level is responsible
for calling this function before and RTS frame is needed.

.. _`ieee80211_rts_duration`:

ieee80211_rts_duration
======================

.. c:function:: __le16 ieee80211_rts_duration(struct ieee80211_hw *hw, struct ieee80211_vif *vif, size_t frame_len, const struct ieee80211_tx_info *frame_txctl)

    Get the duration field for an RTS frame

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param size_t frame_len:
        the length of the frame that is going to be protected by the RTS.

    :param const struct ieee80211_tx_info \*frame_txctl:
        \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  of the frame.

.. _`ieee80211_rts_duration.description`:

Description
-----------

If the RTS is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.

.. _`ieee80211_rts_duration.return`:

Return
------

The duration.

.. _`ieee80211_ctstoself_get`:

ieee80211_ctstoself_get
=======================

.. c:function:: void ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif, const void *frame, size_t frame_len, const struct ieee80211_tx_info *frame_txctl, struct ieee80211_cts *cts)

    CTS-to-self frame generation function

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param const void \*frame:
        pointer to the frame that is going to be protected by the CTS-to-self.

    :param size_t frame_len:
        the frame length (in octets).

    :param const struct ieee80211_tx_info \*frame_txctl:
        \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  of the frame.

    :param struct ieee80211_cts \*cts:
        The buffer where to store the CTS-to-self frame.

.. _`ieee80211_ctstoself_get.description`:

Description
-----------

If the CTS-to-self frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next CTS-to-self frame from the 802.11 code. The low-level is responsible
for calling this function before and CTS-to-self frame is needed.

.. _`ieee80211_ctstoself_duration`:

ieee80211_ctstoself_duration
============================

.. c:function:: __le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw, struct ieee80211_vif *vif, size_t frame_len, const struct ieee80211_tx_info *frame_txctl)

    Get the duration field for a CTS-to-self frame

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param size_t frame_len:
        the length of the frame that is going to be protected by the CTS-to-self.

    :param const struct ieee80211_tx_info \*frame_txctl:
        \ :c:type:`struct ieee80211_tx_info <ieee80211_tx_info>`\  of the frame.

.. _`ieee80211_ctstoself_duration.description`:

Description
-----------

If the CTS-to-self is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.

.. _`ieee80211_ctstoself_duration.return`:

Return
------

The duration.

.. _`ieee80211_generic_frame_duration`:

ieee80211_generic_frame_duration
================================

.. c:function:: __le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw, struct ieee80211_vif *vif, enum nl80211_band band, size_t frame_len, struct ieee80211_rate *rate)

    Calculate the duration field for a frame

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param enum nl80211_band band:
        the band to calculate the frame duration on

    :param size_t frame_len:
        the length of the frame.

    :param struct ieee80211_rate \*rate:
        the rate at which the frame is going to be transmitted.

.. _`ieee80211_generic_frame_duration.description`:

Description
-----------

Calculate the duration field of some generic frame, given its
length and transmission rate (in 100kbps).

.. _`ieee80211_generic_frame_duration.return`:

Return
------

The duration.

.. _`ieee80211_get_buffered_bc`:

ieee80211_get_buffered_bc
=========================

.. c:function:: struct sk_buff *ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    accessing buffered broadcast and multicast frames

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_get_buffered_bc.description`:

Description
-----------

Function for accessing buffered broadcast and multicast frames. If
hardware/firmware does not implement buffering of broadcast/multicast
frames when power saving is used, 802.11 code buffers them in the host
memory. The low-level driver uses this function to fetch next buffered
frame. In most cases, this is used when generating beacon frame.

.. _`ieee80211_get_buffered_bc.return`:

Return
------

A pointer to the next buffered skb or NULL if no more buffered
frames are available.

.. _`ieee80211_get_buffered_bc.note`:

Note
----

buffered frames are returned only after DTIM beacon frame was
generated with \ :c:func:`ieee80211_beacon_get`\  and the low-level driver must thus
call \ :c:func:`ieee80211_beacon_get`\  first. \ :c:func:`ieee80211_get_buffered_bc`\  returns
NULL if the previous generated beacon was not DTIM, so the low-level driver
does not need to check for DTIM beacons separately and should be able to
use common code for all beacons.

.. _`ieee80211_get_tkip_p1k_iv`:

ieee80211_get_tkip_p1k_iv
=========================

.. c:function:: void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf, u32 iv32, u16 *p1k)

    get a TKIP phase 1 key for IV32

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param u32 iv32:
        IV32 to get the P1K for

    :param u16 \*p1k:
        a buffer to which the key will be written, as 5 u16 values

.. _`ieee80211_get_tkip_p1k_iv.description`:

Description
-----------

This function returns the TKIP phase 1 key for the given IV32.

.. _`ieee80211_get_tkip_p1k`:

ieee80211_get_tkip_p1k
======================

.. c:function:: void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf, struct sk_buff *skb, u16 *p1k)

    get a TKIP phase 1 key

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param struct sk_buff \*skb:
        the packet to take the IV32 value from that will be encrypted
        with this P1K

    :param u16 \*p1k:
        a buffer to which the key will be written, as 5 u16 values

.. _`ieee80211_get_tkip_p1k.description`:

Description
-----------

This function returns the TKIP phase 1 key for the IV32 taken
from the given packet.

.. _`ieee80211_get_tkip_rx_p1k`:

ieee80211_get_tkip_rx_p1k
=========================

.. c:function:: void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf, const u8 *ta, u32 iv32, u16 *p1k)

    get a TKIP phase 1 key for RX

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param const u8 \*ta:
        TA that will be used with the key

    :param u32 iv32:
        IV32 to get the P1K for

    :param u16 \*p1k:
        a buffer to which the key will be written, as 5 u16 values

.. _`ieee80211_get_tkip_rx_p1k.description`:

Description
-----------

This function returns the TKIP phase 1 key for the given IV32
and transmitter address.

.. _`ieee80211_get_tkip_p2k`:

ieee80211_get_tkip_p2k
======================

.. c:function:: void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf, struct sk_buff *skb, u8 *p2k)

    get a TKIP phase 2 key

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param struct sk_buff \*skb:
        the packet to take the IV32/IV16 values from that will be
        encrypted with this key

    :param u8 \*p2k:
        a buffer to which the key will be written, 16 bytes

.. _`ieee80211_get_tkip_p2k.description`:

Description
-----------

This function computes the TKIP RC4 key for the IV values
in the packet.

.. _`ieee80211_tkip_add_iv`:

ieee80211_tkip_add_iv
=====================

.. c:function:: u8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn)

    write TKIP IV and Ext. IV to pos

    :param u8 \*pos:
        start of crypto header

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param u64 pn:
        PN to add

.. _`ieee80211_tkip_add_iv.return`:

Return
------

pointer to the octet following IVs (i.e. beginning of
the packet payload)

This function writes the tkip IV value to pos (which should
point to the crypto header)

.. _`ieee80211_get_key_rx_seq`:

ieee80211_get_key_rx_seq
========================

.. c:function:: void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf, int tid, struct ieee80211_key_seq *seq)

    get key RX sequence counter

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param int tid:
        The TID, or -1 for the management frame value (CCMP/GCMP only);
        the value on TID 0 is also used for non-QoS frames. For
        CMAC, only TID 0 is valid.

    :param struct ieee80211_key_seq \*seq:
        buffer to receive the sequence data

.. _`ieee80211_get_key_rx_seq.description`:

Description
-----------

This function allows a driver to retrieve the current RX IV/PNs
for the given key. It must not be called if IV checking is done
by the device and not by mac80211.

Note that this function may only be called when no RX processing
can be done concurrently.

.. _`ieee80211_set_key_rx_seq`:

ieee80211_set_key_rx_seq
========================

.. c:function:: void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf, int tid, struct ieee80211_key_seq *seq)

    set key RX sequence counter

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

    :param int tid:
        The TID, or -1 for the management frame value (CCMP/GCMP only);
        the value on TID 0 is also used for non-QoS frames. For
        CMAC, only TID 0 is valid.

    :param struct ieee80211_key_seq \*seq:
        new sequence data

.. _`ieee80211_set_key_rx_seq.description`:

Description
-----------

This function allows a driver to set the current RX IV/PNs for the
given key. This is useful when resuming from WoWLAN sleep and GTK
rekey may have been done while suspended. It should not be called
if IV checking is done by the device and not by mac80211.

Note that this function may only be called when no RX processing
can be done concurrently.

.. _`ieee80211_remove_key`:

ieee80211_remove_key
====================

.. c:function:: void ieee80211_remove_key(struct ieee80211_key_conf *keyconf)

    remove the given key

    :param struct ieee80211_key_conf \*keyconf:
        the parameter passed with the set key

.. _`ieee80211_remove_key.description`:

Description
-----------

Remove the given key. If the key was uploaded to the hardware at the
time this function is called, it is not deleted in the hardware but
instead assumed to have been removed already.

Note that due to locking considerations this function can (currently)
only be called during key iteration (\ :c:func:`ieee80211_iter_keys`\ .)

.. _`ieee80211_gtk_rekey_add`:

ieee80211_gtk_rekey_add
=======================

.. c:function:: struct ieee80211_key_conf *ieee80211_gtk_rekey_add(struct ieee80211_vif *vif, struct ieee80211_key_conf *keyconf)

    add a GTK key from rekeying during WoWLAN

    :param struct ieee80211_vif \*vif:
        the virtual interface to add the key on

    :param struct ieee80211_key_conf \*keyconf:
        new key data

.. _`ieee80211_gtk_rekey_add.description`:

Description
-----------

When GTK rekeying was done while the system was suspended, (a) new
key(s) will be available. These will be needed by mac80211 for proper
RX processing, so this function allows setting them.

The function returns the newly allocated key structure, which will
have similar contents to the passed key configuration but point to
mac80211-owned memory. In case of errors, the function returns an
\ :c:func:`ERR_PTR`\ , use \ :c:func:`IS_ERR`\  etc.

Note that this function assumes the key isn't added to hardware
acceleration, so no TX will be done with the key. Since it's a GTK
on managed (station) networks, this is true anyway. If the driver
calls this function from the resume callback and subsequently uses
the return code 1 to reconfigure the device, this key will be part
of the reconfiguration.

Note that the driver should also call \ :c:func:`ieee80211_set_key_rx_seq`\ 
for the new key for each TID to set up sequence counters properly.

.. _`ieee80211_gtk_rekey_add.important`:

IMPORTANT
---------

If this replaces a key that is present in the hardware,
then it will attempt to remove it during this call. In many cases
this isn't what you want, so call \ :c:func:`ieee80211_remove_key`\  first for
the key that's being replaced.

.. _`ieee80211_gtk_rekey_notify`:

ieee80211_gtk_rekey_notify
==========================

.. c:function:: void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid, const u8 *replay_ctr, gfp_t gfp)

    notify userspace supplicant of rekeying

    :param struct ieee80211_vif \*vif:
        virtual interface the rekeying was done on

    :param const u8 \*bssid:
        The BSSID of the AP, for checking association

    :param const u8 \*replay_ctr:
        the new replay counter after GTK rekeying

    :param gfp_t gfp:
        allocation flags

.. _`ieee80211_wake_queue`:

ieee80211_wake_queue
====================

.. c:function:: void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue)

    wake specific queue

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param int queue:
        queue number (counted from zero).

.. _`ieee80211_wake_queue.description`:

Description
-----------

Drivers should use this function instead of netif_wake_queue.

.. _`ieee80211_stop_queue`:

ieee80211_stop_queue
====================

.. c:function:: void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue)

    stop specific queue

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param int queue:
        queue number (counted from zero).

.. _`ieee80211_stop_queue.description`:

Description
-----------

Drivers should use this function instead of netif_stop_queue.

.. _`ieee80211_queue_stopped`:

ieee80211_queue_stopped
=======================

.. c:function:: int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue)

    test status of the queue

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param int queue:
        queue number (counted from zero).

.. _`ieee80211_queue_stopped.description`:

Description
-----------

Drivers should use this function instead of netif_stop_queue.

.. _`ieee80211_queue_stopped.return`:

Return
------

\ ``true``\  if the queue is stopped. \ ``false``\  otherwise.

.. _`ieee80211_stop_queues`:

ieee80211_stop_queues
=====================

.. c:function:: void ieee80211_stop_queues(struct ieee80211_hw *hw)

    stop all queues

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

.. _`ieee80211_stop_queues.description`:

Description
-----------

Drivers should use this function instead of netif_stop_queue.

.. _`ieee80211_wake_queues`:

ieee80211_wake_queues
=====================

.. c:function:: void ieee80211_wake_queues(struct ieee80211_hw *hw)

    wake all queues

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ .

.. _`ieee80211_wake_queues.description`:

Description
-----------

Drivers should use this function instead of netif_wake_queue.

.. _`ieee80211_scan_completed`:

ieee80211_scan_completed
========================

.. c:function:: void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted)

    completed hardware scan

    :param struct ieee80211_hw \*hw:
        the hardware that finished the scan

    :param bool aborted:
        set to true if scan was aborted

.. _`ieee80211_scan_completed.description`:

Description
-----------

When hardware scan offload is used (i.e. the \ :c:func:`hw_scan`\  callback is
assigned) this function needs to be called by the driver to notify
mac80211 that the scan finished. This function can be called from
any context, including hardirq context.

.. _`ieee80211_sched_scan_results`:

ieee80211_sched_scan_results
============================

.. c:function:: void ieee80211_sched_scan_results(struct ieee80211_hw *hw)

    got results from scheduled scan

    :param struct ieee80211_hw \*hw:
        the hardware that is performing scheduled scans

.. _`ieee80211_sched_scan_results.description`:

Description
-----------

When a scheduled scan is running, this function needs to be called by the
driver whenever there are new scan results available.

.. _`ieee80211_sched_scan_stopped`:

ieee80211_sched_scan_stopped
============================

.. c:function:: void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw)

    inform that the scheduled scan has stopped

    :param struct ieee80211_hw \*hw:
        the hardware that is performing scheduled scans

.. _`ieee80211_sched_scan_stopped.description`:

Description
-----------

When a scheduled scan is running, this function can be called by
the driver if it needs to stop the scan to perform another task.
Usual scenarios are drivers that cannot continue the scheduled scan
while associating, for instance.

.. _`ieee80211_interface_iteration_flags`:

enum ieee80211_interface_iteration_flags
========================================

.. c:type:: enum ieee80211_interface_iteration_flags

    interface iteration flags

.. _`ieee80211_interface_iteration_flags.definition`:

Definition
----------

.. code-block:: c

    enum ieee80211_interface_iteration_flags {
        IEEE80211_IFACE_ITER_NORMAL,
        IEEE80211_IFACE_ITER_RESUME_ALL,
        IEEE80211_IFACE_ITER_ACTIVE
    };

.. _`ieee80211_interface_iteration_flags.constants`:

Constants
---------

IEEE80211_IFACE_ITER_NORMAL
    Iterate over all interfaces that have
    been added to the driver; However, note that during hardware
    reconfiguration (after restart_hw) it will iterate over a new
    interface and over all the existing interfaces even if they
    haven't been re-added to the driver yet.

IEEE80211_IFACE_ITER_RESUME_ALL
    During resume, iterate over all
    interfaces, even if they haven't been re-added to the driver yet.

IEEE80211_IFACE_ITER_ACTIVE
    Iterate only active interfaces (netdev is up).

.. _`ieee80211_iterate_interfaces`:

ieee80211_iterate_interfaces
============================

.. c:function:: void ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags, void (*iterator)(void *data, u8 *mac, struct ieee80211_vif *vif), void *data)

    iterate interfaces

    :param struct ieee80211_hw \*hw:
        the hardware struct of which the interfaces should be iterated over

    :param u32 iter_flags:
        iteration flags, see \ :c:type:`enum ieee80211_interface_iteration_flags <ieee80211_interface_iteration_flags>`\ 

    :param void (\*iterator)(void \*data, u8 \*mac, struct ieee80211_vif \*vif):
        the iterator function to call

    :param void \*data:
        first argument of the iterator function

.. _`ieee80211_iterate_interfaces.description`:

Description
-----------

This function iterates over the interfaces associated with a given
hardware and calls the callback for them. This includes active as well as
inactive interfaces. This function allows the iterator function to sleep.
Will iterate over a new interface during \ :c:func:`add_interface`\ .

.. _`ieee80211_iterate_active_interfaces`:

ieee80211_iterate_active_interfaces
===================================

.. c:function:: void ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags, void (*iterator)(void *data, u8 *mac, struct ieee80211_vif *vif), void *data)

    iterate active interfaces

    :param struct ieee80211_hw \*hw:
        the hardware struct of which the interfaces should be iterated over

    :param u32 iter_flags:
        iteration flags, see \ :c:type:`enum ieee80211_interface_iteration_flags <ieee80211_interface_iteration_flags>`\ 

    :param void (\*iterator)(void \*data, u8 \*mac, struct ieee80211_vif \*vif):
        the iterator function to call

    :param void \*data:
        first argument of the iterator function

.. _`ieee80211_iterate_active_interfaces.description`:

Description
-----------

This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function allows the iterator function to sleep, when the iterator
function is atomic \ ``ieee80211_iterate_active_interfaces_atomic``\  can
be used.
Does not iterate over a new interface during \ :c:func:`add_interface`\ .

.. _`ieee80211_iterate_active_interfaces_atomic`:

ieee80211_iterate_active_interfaces_atomic
==========================================

.. c:function:: void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw, u32 iter_flags, void (*iterator)(void *data, u8 *mac, struct ieee80211_vif *vif), void *data)

    iterate active interfaces

    :param struct ieee80211_hw \*hw:
        the hardware struct of which the interfaces should be iterated over

    :param u32 iter_flags:
        iteration flags, see \ :c:type:`enum ieee80211_interface_iteration_flags <ieee80211_interface_iteration_flags>`\ 

    :param void (\*iterator)(void \*data, u8 \*mac, struct ieee80211_vif \*vif):
        the iterator function to call, cannot sleep

    :param void \*data:
        first argument of the iterator function

.. _`ieee80211_iterate_active_interfaces_atomic.description`:

Description
-----------

This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function requires the iterator callback function to be atomic,
if that is not desired, use \ ``ieee80211_iterate_active_interfaces``\  instead.
Does not iterate over a new interface during \ :c:func:`add_interface`\ .

.. _`ieee80211_iterate_active_interfaces_rtnl`:

ieee80211_iterate_active_interfaces_rtnl
========================================

.. c:function:: void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw, u32 iter_flags, void (*iterator)(void *data, u8 *mac, struct ieee80211_vif *vif), void *data)

    iterate active interfaces

    :param struct ieee80211_hw \*hw:
        the hardware struct of which the interfaces should be iterated over

    :param u32 iter_flags:
        iteration flags, see \ :c:type:`enum ieee80211_interface_iteration_flags <ieee80211_interface_iteration_flags>`\ 

    :param void (\*iterator)(void \*data, u8 \*mac, struct ieee80211_vif \*vif):
        the iterator function to call, cannot sleep

    :param void \*data:
        first argument of the iterator function

.. _`ieee80211_iterate_active_interfaces_rtnl.description`:

Description
-----------

This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This version can only be used while holding the RTNL.

.. _`ieee80211_iterate_stations_atomic`:

ieee80211_iterate_stations_atomic
=================================

.. c:function:: void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw, void (*iterator)(void *data, struct ieee80211_sta *sta), void *data)

    iterate stations

    :param struct ieee80211_hw \*hw:
        the hardware struct of which the interfaces should be iterated over

    :param void (\*iterator)(void \*data, struct ieee80211_sta \*sta):
        the iterator function to call, cannot sleep

    :param void \*data:
        first argument of the iterator function

.. _`ieee80211_iterate_stations_atomic.description`:

Description
-----------

This function iterates over all stations associated with a given
hardware that are currently uploaded to the driver and calls the callback
function for them.
This function requires the iterator callback function to be atomic,

.. _`ieee80211_queue_work`:

ieee80211_queue_work
====================

.. c:function:: void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work)

    add work onto the mac80211 workqueue

    :param struct ieee80211_hw \*hw:
        the hardware struct for the interface we are adding work for

    :param struct work_struct \*work:
        the work we want to add onto the mac80211 workqueue

.. _`ieee80211_queue_work.description`:

Description
-----------

Drivers and mac80211 use this to add work onto the mac80211 workqueue.
This helper ensures drivers are not queueing work when they should not be.

.. _`ieee80211_queue_delayed_work`:

ieee80211_queue_delayed_work
============================

.. c:function:: void ieee80211_queue_delayed_work(struct ieee80211_hw *hw, struct delayed_work *dwork, unsigned long delay)

    add work onto the mac80211 workqueue

    :param struct ieee80211_hw \*hw:
        the hardware struct for the interface we are adding work for

    :param struct delayed_work \*dwork:
        delayable work to queue onto the mac80211 workqueue

    :param unsigned long delay:
        number of jiffies to wait before queueing

.. _`ieee80211_queue_delayed_work.description`:

Description
-----------

Drivers and mac80211 use this to queue delayed work onto the mac80211
workqueue.

.. _`ieee80211_start_tx_ba_session`:

ieee80211_start_tx_ba_session
=============================

.. c:function:: int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid, u16 timeout)

    Start a tx Block Ack session.

    :param struct ieee80211_sta \*sta:
        the station for which to start a BA session

    :param u16 tid:
        the TID to BA on.

    :param u16 timeout:
        session timeout value (in TUs)

.. _`ieee80211_start_tx_ba_session.return`:

Return
------

success if addBA request was sent, failure otherwise

Although mac80211/low level driver/user space application can estimate
the need to start aggregation on a certain RA/TID, the session level
will be managed by the mac80211.

.. _`ieee80211_start_tx_ba_cb_irqsafe`:

ieee80211_start_tx_ba_cb_irqsafe
================================

.. c:function:: void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra, u16 tid)

    low level driver ready to aggregate.

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback

    :param const u8 \*ra:
        receiver address of the BA session recipient.

    :param u16 tid:
        the TID to BA on.

.. _`ieee80211_start_tx_ba_cb_irqsafe.description`:

Description
-----------

This function must be called by low level driver once it has
finished with preparations for the BA session. It can be called
from any context.

.. _`ieee80211_stop_tx_ba_session`:

ieee80211_stop_tx_ba_session
============================

.. c:function:: int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid)

    Stop a Block Ack session.

    :param struct ieee80211_sta \*sta:
        the station whose BA session to stop

    :param u16 tid:
        the TID to stop BA.

.. _`ieee80211_stop_tx_ba_session.return`:

Return
------

negative error if the TID is invalid, or no aggregation active

Although mac80211/low level driver/user space application can estimate
the need to stop aggregation on a certain RA/TID, the session level
will be managed by the mac80211.

.. _`ieee80211_stop_tx_ba_cb_irqsafe`:

ieee80211_stop_tx_ba_cb_irqsafe
===============================

.. c:function:: void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra, u16 tid)

    low level driver ready to stop aggregate.

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback

    :param const u8 \*ra:
        receiver address of the BA session recipient.

    :param u16 tid:
        the desired TID to BA on.

.. _`ieee80211_stop_tx_ba_cb_irqsafe.description`:

Description
-----------

This function must be called by low level driver once it has
finished with preparations for the BA session tear down. It
can be called from any context.

.. _`ieee80211_find_sta`:

ieee80211_find_sta
==================

.. c:function:: struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif, const u8 *addr)

    find a station

    :param struct ieee80211_vif \*vif:
        virtual interface to look for station on

    :param const u8 \*addr:
        station's address

.. _`ieee80211_find_sta.return`:

Return
------

The station, if found. \ ``NULL``\  otherwise.

.. _`ieee80211_find_sta.note`:

Note
----

This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.

.. _`ieee80211_find_sta_by_ifaddr`:

ieee80211_find_sta_by_ifaddr
============================

.. c:function:: struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw, const u8 *addr, const u8 *localaddr)

    find a station on hardware

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param const u8 \*addr:
        remote station's address

    :param const u8 \*localaddr:
        local address (vif->sdata->vif.addr). Use NULL for 'any'.

.. _`ieee80211_find_sta_by_ifaddr.return`:

Return
------

The station, if found. \ ``NULL``\  otherwise.

.. _`ieee80211_find_sta_by_ifaddr.note`:

Note
----

This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.

.. _`ieee80211_find_sta_by_ifaddr.note`:

NOTE
----

You may pass NULL for localaddr, but then you will just get
the first STA that matches the remote address 'addr'.
We can have multiple STA associated with multiple
logical stations (e.g. consider a station connecting to another
BSSID on the same AP hardware without disconnecting first).
In this case, the result of this method with localaddr NULL
is not reliable.

DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.

.. _`ieee80211_sta_block_awake`:

ieee80211_sta_block_awake
=========================

.. c:function:: void ieee80211_sta_block_awake(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta, bool block)

    block station from waking up

    :param struct ieee80211_hw \*hw:
        the hardware

    :param struct ieee80211_sta \*pubsta:
        the station

    :param bool block:
        whether to block or unblock

.. _`ieee80211_sta_block_awake.description`:

Description
-----------

Some devices require that all frames that are on the queues
for a specific station that went to sleep are flushed before
a poll response or frames after the station woke up can be
delivered to that it. Note that such frames must be rejected
by the driver as filtered, with the appropriate status flag.

This function allows implementing this mode in a race-free
manner.

To do this, a driver must keep track of the number of frames
still enqueued for a specific station. If this number is not
zero when the station goes to sleep, the driver must call
this function to force mac80211 to consider the station to
be asleep regardless of the station's actual state. Once the
number of outstanding frames reaches zero, the driver must
call this function again to unblock the station. That will
cause mac80211 to be able to send ps-poll responses, and if
the station queried in the meantime then frames will also
be sent out as a result of this. Additionally, the driver
will be notified that the station woke up some time after
it is unblocked, regardless of whether the station actually
woke up while blocked or not.

.. _`ieee80211_sta_eosp`:

ieee80211_sta_eosp
==================

.. c:function:: void ieee80211_sta_eosp(struct ieee80211_sta *pubsta)

    notify mac80211 about end of SP

    :param struct ieee80211_sta \*pubsta:
        the station

.. _`ieee80211_sta_eosp.description`:

Description
-----------

When a device transmits frames in a way that it can't tell
mac80211 in the TX status about the EOSP, it must clear the
\ ``IEEE80211_TX_STATUS_EOSP``\  bit and call this function instead.
This applies for PS-Poll as well as uAPSD.

Note that just like with \\ :c:func:`_tx_status`\  and \\ :c:func:`_rx`\  drivers must
not mix calls to irqsafe/non-irqsafe versions, this function
must not be mixed with those either. Use the all irqsafe, or
all non-irqsafe, don't mix!

NB: the \_irqsafe version of this function doesn't exist, no
driver needs it right now. Don't call this function if
you'd need the \_irqsafe version, look at the git history
and restore the \_irqsafe version!

.. _`ieee80211_send_eosp_nullfunc`:

ieee80211_send_eosp_nullfunc
============================

.. c:function:: void ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid)

    ask mac80211 to send NDP with EOSP

    :param struct ieee80211_sta \*pubsta:
        the station

    :param int tid:
        the tid of the NDP

.. _`ieee80211_send_eosp_nullfunc.description`:

Description
-----------

Sometimes the device understands that it needs to close
the Service Period unexpectedly. This can happen when
sending frames that are filling holes in the BA window.
In this case, the device can ask mac80211 to send a
Nullfunc frame with EOSP set. When that happens, the
driver must have called \ :c:func:`ieee80211_sta_set_buffered`\  to
let mac80211 know that there are no buffered frames any
more, otherwise mac80211 will get the more_data bit wrong.
The low level driver must have made sure that the frame
will be sent despite the station being in power-save.
Mac80211 won't call \ :c:func:`allow_buffered_frames`\ .
Note that calling this function, doesn't exempt the driver
from closing the EOSP properly, it will still have to call
ieee80211_sta_eosp when the NDP is sent.

.. _`ieee80211_iter_keys`:

ieee80211_iter_keys
===================

.. c:function:: void ieee80211_iter_keys(struct ieee80211_hw *hw, struct ieee80211_vif *vif, void (*iter)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key, void *data), void *iter_data)

    iterate keys programmed into the device

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param struct ieee80211_vif \*vif:
        virtual interface to iterate, may be \ ``NULL``\  for all

    :param void (\*iter)(struct ieee80211_hw \*hw, struct ieee80211_vif \*vif, struct ieee80211_sta \*sta, struct ieee80211_key_conf \*key, void \*data):
        iterator function that will be called for each key

    :param void \*iter_data:
        custom data to pass to the iterator function

.. _`ieee80211_iter_keys.description`:

Description
-----------

This function can be used to iterate all the keys known to
mac80211, even those that weren't previously programmed into
the device. This is intended for use in WoWLAN if the device
needs reprogramming of the keys during suspend. Note that due
to locking reasons, it is also only safe to call this at few
spots since it must hold the RTNL and be able to sleep.

The order in which the keys are iterated matches the order
in which they were originally installed and handed to the
set_key callback.

.. _`ieee80211_iter_keys_rcu`:

ieee80211_iter_keys_rcu
=======================

.. c:function:: void ieee80211_iter_keys_rcu(struct ieee80211_hw *hw, struct ieee80211_vif *vif, void (*iter)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key, void *data), void *iter_data)

    iterate keys programmed into the device

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param struct ieee80211_vif \*vif:
        virtual interface to iterate, may be \ ``NULL``\  for all

    :param void (\*iter)(struct ieee80211_hw \*hw, struct ieee80211_vif \*vif, struct ieee80211_sta \*sta, struct ieee80211_key_conf \*key, void \*data):
        iterator function that will be called for each key

    :param void \*iter_data:
        custom data to pass to the iterator function

.. _`ieee80211_iter_keys_rcu.description`:

Description
-----------

This function can be used to iterate all the keys known to
mac80211, even those that weren't previously programmed into
the device. Note that due to locking reasons, keys of station
in removal process will be skipped.

This function requires being called in an RCU critical section,
and thus iter must be atomic.

.. _`ieee80211_iter_chan_contexts_atomic`:

ieee80211_iter_chan_contexts_atomic
===================================

.. c:function:: void ieee80211_iter_chan_contexts_atomic(struct ieee80211_hw *hw, void (*iter)(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *chanctx_conf, void *data), void *iter_data)

    iterate channel contexts

    :param struct ieee80211_hw \*hw:
        pointre obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param void (\*iter)(struct ieee80211_hw \*hw, struct ieee80211_chanctx_conf \*chanctx_conf, void \*data):
        iterator function

    :param void \*iter_data:
        data passed to iterator function

.. _`ieee80211_iter_chan_contexts_atomic.description`:

Description
-----------

Iterate all active channel contexts. This function is atomic and
doesn't acquire any locks internally that might be held in other
places while calling into the driver.

The iterator will not find a context that's being added (during
the driver callback to add it) but will find it while it's being
removed.

Note that during hardware restart, all contexts that existed
before the restart are considered already present so will be
found while iterating, whether they've been re-added already
or not.

.. _`ieee80211_ap_probereq_get`:

ieee80211_ap_probereq_get
=========================

.. c:function:: struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

    retrieve a Probe Request template

    :param struct ieee80211_hw \*hw:
        pointer obtained from \ :c:func:`ieee80211_alloc_hw`\ .

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_ap_probereq_get.description`:

Description
-----------

Creates a Probe Request template which can, for example, be uploaded to
hardware. The template is filled with bssid, ssid and supported rate
information. This function must only be called from within the
.bss_info_changed callback function and only in managed mode. The function
is only useful when the interface is associated, otherwise it will return
\ ``NULL``\ .

.. _`ieee80211_ap_probereq_get.return`:

Return
------

The Probe Request template. \ ``NULL``\  on error.

.. _`ieee80211_beacon_loss`:

ieee80211_beacon_loss
=====================

.. c:function:: void ieee80211_beacon_loss(struct ieee80211_vif *vif)

    inform hardware does not receive beacons

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_beacon_loss.description`:

Description
-----------

When beacon filtering is enabled with \ ``IEEE80211_VIF_BEACON_FILTER``\  and
\ ``IEEE80211_CONF_PS``\  is set, the driver needs to inform whenever the
hardware is not receiving beacons with this function.

.. _`ieee80211_connection_loss`:

ieee80211_connection_loss
=========================

.. c:function:: void ieee80211_connection_loss(struct ieee80211_vif *vif)

    inform hardware has lost connection to the AP

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_connection_loss.description`:

Description
-----------

When beacon filtering is enabled with \ ``IEEE80211_VIF_BEACON_FILTER``\ , and
\ ``IEEE80211_CONF_PS``\  and \ ``IEEE80211_HW_CONNECTION_MONITOR``\  are set, the driver
needs to inform if the connection to the AP has been lost.
The function may also be called if the connection needs to be terminated
for some other reason, even if \ ``IEEE80211_HW_CONNECTION_MONITOR``\  isn't set.

This function will cause immediate change to disassociated state,
without connection recovery attempts.

.. _`ieee80211_resume_disconnect`:

ieee80211_resume_disconnect
===========================

.. c:function:: void ieee80211_resume_disconnect(struct ieee80211_vif *vif)

    disconnect from AP after resume

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

.. _`ieee80211_resume_disconnect.description`:

Description
-----------

Instructs mac80211 to disconnect from the AP after resume.
Drivers can use this after WoWLAN if they know that the
connection cannot be kept up, for example because keys were
used while the device was asleep but the replay counters or
similar cannot be retrieved from the device during resume.

Note that due to implementation issues, if the driver uses
the reconfiguration functionality during resume the interface
will still be added as associated first during resume and then
disconnect normally later.

This function can only be called from the resume callback and
the driver must not be holding any of its own locks while it
calls this function, or at least not any locks it needs in the
key configuration paths (if it supports HW crypto).

.. _`ieee80211_cqm_rssi_notify`:

ieee80211_cqm_rssi_notify
=========================

.. c:function:: void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif, enum nl80211_cqm_rssi_threshold_event rssi_event, gfp_t gfp)

    inform a configured connection quality monitoring rssi threshold triggered

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param enum nl80211_cqm_rssi_threshold_event rssi_event:
        the RSSI trigger event type

    :param gfp_t gfp:
        context flags

.. _`ieee80211_cqm_rssi_notify.description`:

Description
-----------

When the \ ``IEEE80211_VIF_SUPPORTS_CQM_RSSI``\  is set, and a connection quality
monitoring is configured with an rssi threshold, the driver will inform
whenever the rssi level reaches the threshold.

.. _`ieee80211_cqm_beacon_loss_notify`:

ieee80211_cqm_beacon_loss_notify
================================

.. c:function:: void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp)

    inform CQM of beacon loss

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param gfp_t gfp:
        context flags

.. _`ieee80211_radar_detected`:

ieee80211_radar_detected
========================

.. c:function:: void ieee80211_radar_detected(struct ieee80211_hw *hw)

    inform that a radar was detected

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

.. _`ieee80211_chswitch_done`:

ieee80211_chswitch_done
=======================

.. c:function:: void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)

    Complete channel switch process

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param bool success:
        make the channel switch successful or not

.. _`ieee80211_chswitch_done.description`:

Description
-----------

Complete the channel switch post-process: set the new operational channel
and wake up the suspended queues.

.. _`ieee80211_request_smps`:

ieee80211_request_smps
======================

.. c:function:: void ieee80211_request_smps(struct ieee80211_vif *vif, enum ieee80211_smps_mode smps_mode)

    request SM PS transition

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param enum ieee80211_smps_mode smps_mode:
        new SM PS mode

.. _`ieee80211_request_smps.description`:

Description
-----------

This allows the driver to request an SM PS transition in managed
mode. This is useful when the driver has more information than
the stack about possible interference, for example by bluetooth.

.. _`ieee80211_ready_on_channel`:

ieee80211_ready_on_channel
==========================

.. c:function:: void ieee80211_ready_on_channel(struct ieee80211_hw *hw)

    notification of remain-on-channel start

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

.. _`ieee80211_remain_on_channel_expired`:

ieee80211_remain_on_channel_expired
===================================

.. c:function:: void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)

    remain_on_channel duration expired

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

.. _`ieee80211_stop_rx_ba_session`:

ieee80211_stop_rx_ba_session
============================

.. c:function:: void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap, const u8 *addr)

    callback to stop existing BA sessions

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param u16 ba_rx_bitmap:
        Bit map of open rx ba per tid

    :param const u8 \*addr:
        & to bssid mac address

.. _`ieee80211_stop_rx_ba_session.description`:

Description
-----------

in order not to harm the system performance and user experience, the device
may request not to allow any rx ba session and tear down existing rx ba
sessions based on system constraints such as periodic BT activity that needs
to limit wlan activity (eg.sco or a2dp)."
in such cases, the intention is to limit the duration of the rx ppdu and
therefore prevent the peer device to use a-mpdu aggregation.

.. _`ieee80211_mark_rx_ba_filtered_frames`:

ieee80211_mark_rx_ba_filtered_frames
====================================

.. c:function:: void ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid, u16 ssn, u64 filtered, u16 received_mpdus)

    move RX BA window and mark filtered

    :param struct ieee80211_sta \*pubsta:
        station struct

    :param u8 tid:
        the session's TID

    :param u16 ssn:
        starting sequence number of the bitmap, all frames before this are
        assumed to be out of the window after the call

    :param u64 filtered:
        bitmap of filtered frames, BIT(0) is the \ ``ssn``\  entry etc.

    :param u16 received_mpdus:
        number of received mpdus in firmware

.. _`ieee80211_mark_rx_ba_filtered_frames.description`:

Description
-----------

This function moves the BA window and releases all frames before \ ``ssn``\ , and
marks frames marked in the bitmap as having been filtered. Afterwards, it
checks if any frames in the window starting from \ ``ssn``\  can now be released
(in case they were only waiting for frames that were filtered.)

.. _`ieee80211_send_bar`:

ieee80211_send_bar
==================

.. c:function:: void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)

    send a BlockAckReq frame

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback.

    :param u8 \*ra:
        the peer's destination address

    :param u16 tid:
        the TID of the aggregation session

    :param u16 ssn:
        the new starting sequence number for the receiver

.. _`ieee80211_send_bar.description`:

Description
-----------

can be used to flush pending frames from the peer's aggregation reorder
buffer.

.. _`ieee80211_start_rx_ba_session_offl`:

ieee80211_start_rx_ba_session_offl
==================================

.. c:function:: void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif, const u8 *addr, u16 tid)

    start a Rx BA session

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback

    :param const u8 \*addr:
        station mac address

    :param u16 tid:
        the rx tid

.. _`ieee80211_start_rx_ba_session_offl.description`:

Description
-----------

Some device drivers may offload part of the Rx aggregation flow including
AddBa/DelBa negotiation but may otherwise be incapable of full Rx
reordering.

Create structures responsible for reordering so device drivers may call here
when they complete AddBa negotiation.

.. _`ieee80211_stop_rx_ba_session_offl`:

ieee80211_stop_rx_ba_session_offl
=================================

.. c:function:: void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif, const u8 *addr, u16 tid)

    stop a Rx BA session

    :param struct ieee80211_vif \*vif:
        \ :c:type:`struct ieee80211_vif <ieee80211_vif>`\  pointer from the add_interface callback

    :param const u8 \*addr:
        station mac address

    :param u16 tid:
        the rx tid

.. _`ieee80211_stop_rx_ba_session_offl.description`:

Description
-----------

Some device drivers may offload part of the Rx aggregation flow including
AddBa/DelBa negotiation but may otherwise be incapable of full Rx
reordering.

Destroy structures responsible for reordering so device drivers may call here
when they complete DelBa negotiation.

.. _`ieee80211_tx_rate_control`:

struct ieee80211_tx_rate_control
================================

.. c:type:: struct ieee80211_tx_rate_control

    rate control information for/from RC algo

.. _`ieee80211_tx_rate_control.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_tx_rate_control {
        struct ieee80211_hw *hw;
        struct ieee80211_supported_band *sband;
        struct ieee80211_bss_conf *bss_conf;
        struct sk_buff *skb;
        struct ieee80211_tx_rate reported_rate;
        bool rts;
        bool short_preamble;
        u8 max_rate_idx;
        u32 rate_idx_mask;
        u8 *rate_idx_mcs_mask;
        bool bss;
    }

.. _`ieee80211_tx_rate_control.members`:

Members
-------

hw
    The hardware the algorithm is invoked for.

sband
    The band this frame is being transmitted on.

bss_conf
    the current BSS configuration

skb
    the skb that will be transmitted, the control information in it needs
    to be filled in

reported_rate
    The rate control algorithm can fill this in to indicate
    which rate should be reported to userspace as the current rate and
    used for rate calculations in the mesh network.

rts
    whether RTS will be used for this frame because it is longer than the
    RTS threshold

short_preamble
    whether mac80211 will request short-preamble transmission
    if the selected rate supports it

max_rate_idx
    user-requested maximum (legacy) rate
    (deprecated; this will be removed once drivers get updated to use
    rate_idx_mask)

rate_idx_mask
    user-requested (legacy) rate mask

rate_idx_mcs_mask
    user-requested MCS rate mask (NULL if not in use)

bss
    whether this frame is sent out in AP or IBSS mode

.. _`rate_control_send_low`:

rate_control_send_low
=====================

.. c:function:: bool rate_control_send_low(struct ieee80211_sta *sta, void *priv_sta, struct ieee80211_tx_rate_control *txrc)

    helper for drivers for management/no-ack frames

    :param struct ieee80211_sta \*sta:
        \ :c:type:`struct ieee80211_sta <ieee80211_sta>`\  pointer to the target destination. Note
        that this may be null.

    :param void \*priv_sta:
        private rate control structure. This may be null.

    :param struct ieee80211_tx_rate_control \*txrc:
        rate control information we sholud populate for mac80211.

.. _`rate_control_send_low.description`:

Description
-----------

Rate control algorithms that agree to use the lowest rate to
send management frames and NO_ACK data with the respective hw
retries should use this in the beginning of their mac80211 get_rate
callback. If true is returned the rate control can simply return.
If false is returned we guarantee that sta and sta and priv_sta is
not null.

Rate control algorithms wishing to do more intelligent selection of
rate for multicast/broadcast frames may choose to not use this.

.. _`rate_control_set_rates`:

rate_control_set_rates
======================

.. c:function:: int rate_control_set_rates(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta, struct ieee80211_sta_rates *rates)

    pass the sta rate selection to mac80211/driver

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param struct ieee80211_sta \*pubsta:
        \ :c:type:`struct ieee80211_sta <ieee80211_sta>`\  pointer to the target destination.

    :param struct ieee80211_sta_rates \*rates:
        new tx rate set to be used for this station.

.. _`rate_control_set_rates.description`:

Description
-----------

When not doing a rate control probe to test rates, rate control should pass
its rate selection to mac80211. If the driver supports receiving a station
rate table, it will use it to ensure that frames are always sent based on
the most recent rate control module decision.

.. _`ieee80211_update_mu_groups`:

ieee80211_update_mu_groups
==========================

.. c:function:: void ieee80211_update_mu_groups(struct ieee80211_vif *vif, const u8 *membership, const u8 *position)

    set the VHT MU-MIMO groud data

    :param struct ieee80211_vif \*vif:
        the specified virtual interface

    :param const u8 \*membership:
        64 bits array - a bit is set if station is member of the group

    :param const u8 \*position:
        2 bits per group id indicating the position in the group

.. _`ieee80211_update_mu_groups.note`:

Note
----

This function assumes that the given vif is valid and the position and
membership data is of the correct size and are in the same byte order as the
matching GroupId management frame.
Calls to this function need to be serialized with RX path.

.. _`ieee80211_ave_rssi`:

ieee80211_ave_rssi
==================

.. c:function:: int ieee80211_ave_rssi(struct ieee80211_vif *vif)

    report the average RSSI for the specified interface

    :param struct ieee80211_vif \*vif:
        the specified virtual interface

.. _`ieee80211_ave_rssi.note`:

Note
----

This function assumes that the given vif is valid.

.. _`ieee80211_ave_rssi.return`:

Return
------

The average RSSI value for the requested interface, or 0 if not
applicable.

.. _`ieee80211_report_wowlan_wakeup`:

ieee80211_report_wowlan_wakeup
==============================

.. c:function:: void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif, struct cfg80211_wowlan_wakeup *wakeup, gfp_t gfp)

    report WoWLAN wakeup

    :param struct ieee80211_vif \*vif:
        virtual interface

    :param struct cfg80211_wowlan_wakeup \*wakeup:
        wakeup reason(s)

    :param gfp_t gfp:
        allocation flags

.. _`ieee80211_report_wowlan_wakeup.description`:

Description
-----------

See \ :c:func:`cfg80211_report_wowlan_wakeup`\ .

.. _`ieee80211_tx_prepare_skb`:

ieee80211_tx_prepare_skb
========================

.. c:function:: bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct sk_buff *skb, int band, struct ieee80211_sta **sta)

    prepare an 802.11 skb for transmission

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param struct ieee80211_vif \*vif:
        virtual interface

    :param struct sk_buff \*skb:
        frame to be sent from within the driver

    :param int band:
        the band to transmit on

    :param struct ieee80211_sta \*\*sta:
        optional pointer to get the station to send the frame to

.. _`ieee80211_tx_prepare_skb.note`:

Note
----

must be called under RCU lock

.. _`ieee80211_noa_data`:

struct ieee80211_noa_data
=========================

.. c:type:: struct ieee80211_noa_data

    holds temporary data for tracking P2P NoA state

.. _`ieee80211_noa_data.definition`:

Definition
----------

.. code-block:: c

    struct ieee80211_noa_data {
        u32 next_tsf;
        bool has_next_tsf;
        u8 absent;
        u8 count[IEEE80211_P2P_NOA_DESC_MAX];
        struct desc[IEEE80211_P2P_NOA_DESC_MAX];
    }

.. _`ieee80211_noa_data.members`:

Members
-------

next_tsf
    TSF timestamp of the next absent state change

has_next_tsf
    next absent state change event pending

absent
    descriptor bitmask, set if GO is currently absent

count
    count fields from the NoA descriptors

desc
    adjusted data from the NoA

.. _`ieee80211_parse_p2p_noa`:

ieee80211_parse_p2p_noa
=======================

.. c:function:: int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr, struct ieee80211_noa_data *data, u32 tsf)

    initialize NoA tracking data from P2P IE

    :param const struct ieee80211_p2p_noa_attr \*attr:
        P2P NoA IE

    :param struct ieee80211_noa_data \*data:
        NoA tracking data

    :param u32 tsf:
        current TSF timestamp

.. _`ieee80211_parse_p2p_noa.return`:

Return
------

number of successfully parsed descriptors

.. _`ieee80211_update_p2p_noa`:

ieee80211_update_p2p_noa
========================

.. c:function:: void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf)

    get next pending P2P GO absent state change

    :param struct ieee80211_noa_data \*data:
        NoA tracking data

    :param u32 tsf:
        current TSF timestamp

.. _`ieee80211_tdls_oper_request`:

ieee80211_tdls_oper_request
===========================

.. c:function:: void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer, enum nl80211_tdls_operation oper, u16 reason_code, gfp_t gfp)

    request userspace to perform a TDLS operation

    :param struct ieee80211_vif \*vif:
        virtual interface

    :param const u8 \*peer:
        the peer's destination address

    :param enum nl80211_tdls_operation oper:
        the requested TDLS operation

    :param u16 reason_code:
        reason code for the operation, valid for TDLS teardown

    :param gfp_t gfp:
        allocation flags

.. _`ieee80211_tdls_oper_request.description`:

Description
-----------

See \ :c:func:`cfg80211_tdls_oper_request`\ .

.. _`ieee80211_reserve_tid`:

ieee80211_reserve_tid
=====================

.. c:function:: int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid)

    request to reserve a specific TID

    :param struct ieee80211_sta \*sta:
        the station to reserve the TID for

    :param u8 tid:
        the TID to reserve

.. _`ieee80211_reserve_tid.description`:

Description
-----------

There is sometimes a need (such as in TDLS) for blocking the driver from
using a specific TID so that the FW can use it for certain operations such
as sending PTI requests. To make sure that the driver doesn't use that TID,
this function must be called as it flushes out packets on this TID and marks
it as blocked, so that any transmit for the station on this TID will be
redirected to the alternative TID in the same AC.

Note that this function blocks and may call back into the driver, so it
should be called without driver locks held. Also note this function should
only be called from the driver's \ ``sta_state``\  callback.

.. _`ieee80211_reserve_tid.return`:

Return
------

0 on success, else on failure

.. _`ieee80211_unreserve_tid`:

ieee80211_unreserve_tid
=======================

.. c:function:: void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid)

    request to unreserve a specific TID

    :param struct ieee80211_sta \*sta:
        the station

    :param u8 tid:
        the TID to unreserve

.. _`ieee80211_unreserve_tid.description`:

Description
-----------

Once there is no longer any need for reserving a certain TID, this function
should be called, and no longer will packets have their TID modified for
preventing use of this TID in the driver.

Note that this function blocks and acquires a lock, so it should be called
without driver locks held. Also note this function should only be called
from the driver's \ ``sta_state``\  callback.

.. _`ieee80211_tx_dequeue`:

ieee80211_tx_dequeue
====================

.. c:function:: struct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw, struct ieee80211_txq *txq)

    dequeue a packet from a software tx queue

    :param struct ieee80211_hw \*hw:
        pointer as obtained from \ :c:func:`ieee80211_alloc_hw`\ 

    :param struct ieee80211_txq \*txq:
        pointer obtained from station or virtual interface

.. _`ieee80211_tx_dequeue.description`:

Description
-----------

Returns the skb if successful, \ ``NULL``\  if no frame was available.

.. _`ieee80211_txq_get_depth`:

ieee80211_txq_get_depth
=======================

.. c:function:: void ieee80211_txq_get_depth(struct ieee80211_txq *txq, unsigned long *frame_cnt, unsigned long *byte_cnt)

    get pending frame/byte count of given txq

    :param struct ieee80211_txq \*txq:
        pointer obtained from station or virtual interface

    :param unsigned long \*frame_cnt:
        pointer to store frame count

    :param unsigned long \*byte_cnt:
        pointer to store byte count

.. _`ieee80211_txq_get_depth.description`:

Description
-----------

The values are not guaranteed to be coherent with regard to each other, i.e.
txq state can change half-way of this function and the caller may end up
with "new" frame_cnt and "old" byte_cnt or vice-versa.

.. This file was automatic generated / don't edit.

