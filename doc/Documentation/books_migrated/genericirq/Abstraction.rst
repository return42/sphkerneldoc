.. -*- coding: utf-8; mode: rst -*-

.. _Abstraction:

******************
Abstraction layers
******************

There are three main levels of abstraction in the interrupt code:

1. High-level driver API

2. High-level IRQ flow handlers

3. Chip-level hardware encapsulation


.. _Interrupt_control_flow:

Interrupt control flow
======================

Each interrupt is described by an interrupt descriptor structure
irq_desc. The interrupt is referenced by an 'unsigned int' numeric
value which selects the corresponding interrupt description structure in
the descriptor structures array. The descriptor structure contains
status information and pointers to the interrupt flow method and the
interrupt chip structure which are assigned to this interrupt.

Whenever an interrupt triggers, the low-level architecture code calls
into the generic interrupt code by calling desc->handle_irq(). This
high-level IRQ handling function only uses desc->irq_data.chip
primitives referenced by the assigned chip descriptor structure.


.. _Highlevel_Driver_API:

High-level Driver API
=====================

The high-level Driver API consists of following functions:

-  request_irq()

-  free_irq()

-  disable_irq()

-  enable_irq()

-  disable_irq_nosync() (SMP only)

-  synchronize_irq() (SMP only)

-  irq_set_irq_type()

-  irq_set_irq_wake()

-  irq_set_handler_data()

-  irq_set_chip()

-  irq_set_chip_data()

See the autogenerated function documentation for details.


.. _Highlevel_IRQ_flow_handlers:

High-level IRQ flow handlers
============================

The generic layer provides a set of pre-defined irq-flow methods:

-  handle_level_irq

-  handle_edge_irq

-  handle_fasteoi_irq

-  handle_simple_irq

-  handle_percpu_irq

-  handle_edge_eoi_irq

-  handle_bad_irq

The interrupt flow handlers (either pre-defined or architecture
specific) are assigned to specific interrupts by the architecture either
during bootup or during device initialization.


.. _Default_flow_implementations:

Default flow implementations
----------------------------


.. _Helper_functions:

Helper functions
^^^^^^^^^^^^^^^^

The helper functions call the chip primitives and are used by the
default flow implementations. The following helper functions are
implemented (simplified excerpt):


.. code-block:: c

    default_enable(struct irq_data *data)
    {
        desc->irq_data.chip->irq_unmask(data);
    }

    default_disable(struct irq_data *data)
    {
        if (!delay_disable(data))
            desc->irq_data.chip->irq_mask(data);
    }

    default_ack(struct irq_data *data)
    {
        chip->irq_ack(data);
    }

    default_mask_ack(struct irq_data *data)
    {
        if (chip->irq_mask_ack) {
            chip->irq_mask_ack(data);
        } else {
            chip->irq_mask(data);
            chip->irq_ack(data);
        }
    }

    noop(struct irq_data *data))
    {
    }


.. _Default_flow_handler_implementations:

Default flow handler implementations
------------------------------------


.. _Default_Level_IRQ_flow_handler:

Default Level IRQ flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

handle_level_irq provides a generic implementation for level-triggered
interrupts.

The following control flow is implemented (simplified excerpt):


.. code-block:: c

    desc->irq_data.chip->irq_mask_ack();
    handle_irq_event(desc->action);
    desc->irq_data.chip->irq_unmask();


.. _Default_FASTEOI_IRQ_flow_handler:

Default Fast EOI IRQ flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

handle_fasteoi_irq provides a generic implementation for interrupts,
which only need an EOI at the end of the handler.

The following control flow is implemented (simplified excerpt):


.. code-block:: c

    handle_irq_event(desc->action);
    desc->irq_data.chip->irq_eoi();


.. _Default_Edge_IRQ_flow_handler:

Default Edge IRQ flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

handle_edge_irq provides a generic implementation for edge-triggered
interrupts.

The following control flow is implemented (simplified excerpt):


.. code-block:: c

    if (desc->status & running) {
        desc->irq_data.chip->irq_mask_ack();
        desc->status |= pending | masked;
        return;
    }
    desc->irq_data.chip->irq_ack();
    desc->status |= running;
    do {
        if (desc->status & masked)
            desc->irq_data.chip->irq_unmask();
        desc->status &= ~pending;
        handle_irq_event(desc->action);
    } while (status & pending);
    desc->status &= ~running;


.. _Default_simple_IRQ_flow_handler:

Default simple IRQ flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

handle_simple_irq provides a generic implementation for simple
interrupts.

Note: The simple flow handler does not call any handler/chip primitives.

The following control flow is implemented (simplified excerpt):


.. code-block:: c

    handle_irq_event(desc->action);


.. _Default_per_CPU_flow_handler:

Default per CPU flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

handle_percpu_irq provides a generic implementation for per CPU
interrupts.

Per CPU interrupts are only available on SMP and the handler provides a
simplified version without locking.

The following control flow is implemented (simplified excerpt):


.. code-block:: c

    if (desc->irq_data.chip->irq_ack)
        desc->irq_data.chip->irq_ack();
    handle_irq_event(desc->action);
    if (desc->irq_data.chip->irq_eoi)
            desc->irq_data.chip->irq_eoi();


.. _EOI_Edge_IRQ_flow_handler:

EOI Edge IRQ flow handler
^^^^^^^^^^^^^^^^^^^^^^^^^

handle_edge_eoi_irq provides an abnomination of the edge handler
which is solely used to tame a badly wreckaged irq controller on
powerpc/cell.


.. _BAD_IRQ_flow_handler:

Bad IRQ flow handler
^^^^^^^^^^^^^^^^^^^^

handle_bad_irq is used for spurious interrupts which have no real
handler assigned..


.. _Quirks_and_optimizations:

Quirks and optimizations
------------------------

The generic functions are intended for 'clean' architectures and chips,
which have no platform-specific IRQ handling quirks. If an architecture
needs to implement quirks on the 'flow' level then it can do so by
overriding the high-level irq-flow handler.


.. _Delayed_interrupt_disable:

Delayed interrupt disable
-------------------------

This per interrupt selectable feature, which was introduced by Russell
King in the ARM interrupt implementation, does not mask an interrupt at
the hardware level when disable_irq() is called. The interrupt is kept
enabled and is masked in the flow handler when an interrupt event
happens. This prevents losing edge interrupts on hardware which does not
store an edge interrupt event while the interrupt is disabled at the
hardware level. When an interrupt arrives while the IRQ_DISABLED flag
is set, then the interrupt is masked at the hardware level and the
IRQ_PENDING bit is set. When the interrupt is re-enabled by
enable_irq() the pending bit is checked and if it is set, the interrupt
is resent either via hardware or by a software resend mechanism. (It's
necessary to enable CONFIG_HARDIRQS_SW_RESEND when you want to use
the delayed interrupt disable feature and your hardware is not capable
of retriggering an interrupt.) The delayed interrupt disable is not
configurable.


.. _Chiplevel_hardware_encapsulation:

Chip-level hardware encapsulation
=================================

The chip-level hardware descriptor structure irq_chip contains all the
direct chip relevant functions, which can be utilized by the irq flow
implementations.

-  irq_ack()

-  irq_mask_ack() - Optional, recommended for performance

-  irq_mask()

-  irq_unmask()

-  irq_eoi() - Optional, required for EOI flow handlers

-  irq_retrigger() - Optional

-  irq_set_type() - Optional

-  irq_set_wake() - Optional

These primitives are strictly intended to mean what they say: ack means
ACK, masking means masking of an IRQ line, etc. It is up to the flow
handler(s) to use these basic units of low-level functionality.


.. ------------------------------------------------------------------------------
.. This file was automatically converted from DocBook-XML with the dbxml
.. library (https://github.com/return42/dbxml2rst). The origin XML comes
.. from the linux kernel:
..
..   http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git
.. ------------------------------------------------------------------------------
